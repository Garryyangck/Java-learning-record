# 1.Java系列

## 1.Java基础

### 1.介绍一下 Object 常见方法？🌟🌟🌟🌟🌟

==我的回答==：

1. Object 的常用方法包括  getClass(), equals(Object), hashCode(), toString(), notify(), notifyAll(), wait(无参/long/long, int), finalize() ，下面我将一一进行介绍。

2. getClass() 方法用于返回对象==运行时的类对象(Class对象)==。可进一步获取某一对象运行时类的信息。

	> ```java
	> /* Returns the runtime class of this {@code Object}.
	> ```

3. equals 方法==默认情况下使用 == ， 比较引用类型是否相等==。比如 String 类中就重写了此方法，优先比较两对象的地址和运行时类是否相同，随后以比较字符串的方式比较两个 String 对象。

4. hashCode  方法==在默认情况下根据对象的内存地址返回一个int整数==。

	```java
	/* This is typically implemented by converting the internal address of the object into an integer
	```

	==值得注意的是：由于 hashCode 方法可以被重写，因此其返回值不能直接和对象的内存地址挂钩==。hashCode 方法可以用于==帮助 HashMap 实现哈希映射==，但是一个对象在 HashMap 中映射的结果并不等同于其 hashCode，而是基于 hashCode 做了一层封装。

	```java
	static final int hash(Object key) {
	    int h;
	    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
	}
	```

	此外还规定：==如果两个对象使用 equals 方法得到 true 的话，那么它们的 hashCode 必须相同==。

	```java
	/* If two objects are equal according to the {@code equals(Object)} method, then calling the {@code hashCode} method on each of the two objects must produce the same integer result.
	```

	所以==一般两个方法会一同被重写==。

	```java
	@Override
	public boolean equals(Object o) {
	    if (this == o) return true; // 先判断内存地址是否一致，相同则必然相等
	    if (o == null || getClass() != o.getClass()) return false; // 然后判断两对象的运行
	    // 时类型（getClass( )方法）是否与该对象一致，不一致就肯定不相等
	    ThisClass that = (ThisClass) o;
	    return field1 == that.field1 && // 基本数据类型字段直接判断值是否相等
	        field2.equals(that.field2) && // 引用类型则调用其各自的 equals 方法
	        field3.equals(that.field3); // field1 为基本类型，2、3为引用类型
	}
	
	@Override
	public int hashCode() { // 同时重写 hashCode 方法
	    return Objects.hash(field1, field2, field3);
	}
	```

5.  toString  方法用于生成一个 String 字符串以描述一个对象。==默认情况下为==

	```java
	object.getClass().getName() + "@" + Integer.toHexString(object.hashCode())
	```

	==建议所有的类都自行实现 toString 方法==，以更友好的方式告诉程序员某个对象。

6. wait(无参/long/long, int) 方法用于==将此对象上的线程置于等待状态==，直到它被另一个线程以该对象的 notify 方法或 notifyAll() 方法唤醒。

7. notify(), notifyAll() 用于==唤醒某一对象上处于等待状态的线程==。值得注意的是， notify() 随机挑选一个线程唤醒，而另一个则唤醒全部线程。

8. finalize() 方法用于在JVM垃圾回收阶段，==当一个对象将被回收时，会先调用其 finalize() 方法==，目的是==尝试让该对象获得 GC Roots 的引用以逃过这次回收==。

==参考答案==：

- Object 类常见的方法有 toString( )，equals( ) 和 hashCode( )，wait( ) 和 notify( ) 等等。下面分别说一下：
- ==toString( ) 返回的是对象的字符串表示==，==默认为 「class 名 + @ + hashCode 的十六进制表示」==，我们一般会在子类将它重写为打印各个字段的值，==在调试和打日志中用的多==。
- ==equals( ) 和 hashCode( ) 通常用于对象之间的比较==。其中 equals( ) 用于判断两个对象是否相等，==默认使用 “= =” 判断==，hashCode( ) 用于获取对象的哈希码，==默认以对象的内存地址为参考==。在实践中，==为了保证元素在 HashMap 和 HashSet 等集合中的正确存储，通常需要将它俩一起重写==。
- wait( )，notify( ) 以及 notifyAll( ) 通常用于==线程间的协作和同步==。其中 ==wait( ) 使当前线程释放锁并进入等待状态==，直至被其它线程的 notify 或 notifyAll 唤醒。
- notify( ) 会在对该对象调用了 wait( ) 的线程中，==随机挑选一个唤醒，解除其阻塞状态==。而 notifyAll( ) 会唤醒==所有==在该对象上等待的线程。==wait( ) 搭配 notify( ) 可以实现一个简单的“生产-消费模型”：生产者线程产生消息后，调用 notify( ) 唤醒消费者。消费者被唤醒后消费消息，消费完成后调用 wait( ) 等待==。

> 参考答案里举了更多的例子，使得回答更形象具体，让面试官感觉你是真的懂并且能够正确运用，而不是只会干巴巴地背诵。

---



### 2.Java为什么被称为平台无关性语言？🌟🌟🌟🌟🌟

==我的回答==：

1. 首先我想说说==什么是平台无关性语言==。平台无关性语言是指“==一次编译，处处运行(Write once, run anywhere)==”的语言，平台无关性是java的设计者在设计java时的美好愿景。
2. Java实现“一次编译，处处运行”的方法是通过==javac编译器将Java源代码编译为的字节码==，而==不同的操作系统有不同的JVM==，==JVM将同一份字节码翻译为对应操作系统的指令集==，这样就让原本不能跨平台的Java源代码实现了平台无关性。

==参考答案==：

- 平台无关性是说，==一种语言在一台计算机上的运行不受平台的限制，一次编译，到处运行==。
- Java 语言具有平台无关性的关键在于 JVM。虽然==不同的操作系统使用不同的机器指令集来执行任务，同一份代码在不同的操作系统上可能无法直接执行==，但是 Java 源文件经过 ==javac 编译器编译后形成的二进制字节码，可以被各个操作系统的 JVM 翻译成该操作系统所需的指令集==，进而执行。这可以提高 Java 程序的可移植性，因为==只需针对不同操作系统提供对应的 JVM 即可，无需修改源代码==。

---



### 3.= =和equals有什么区别？🌟🌟🌟🌟🌟

==我的回答==：

1. ====是一个操作符==，可以比较==基本数据类型==之间和==引用数据类型==之间是否相等。而 ==equals 是 Object 类的一个方法==，==只能比较两个引用数据类型==是否相等。

2. 具体地说，====比较基本数据类型时，就直接比较值是否相等==。比如int就比较整型值是否相等，boolean就比较布尔值。而==\==比较引用数据类型时，则比较对象的内存地址是否一致==。

3. 而 ==equals 方法在 Object 方法中就是使用 == 比较两个对象是否相等==：

	```java
	public boolean equals(Object obj) {
	    return (this == obj);
	}
	```

	但是==我们可以根据不同对象的意义重写此方法==，以自定义的方式判断两个对象是否相等。比如 String 类就重写了 equals 方法，优先判断两个对象的内存地址和运行时类型是否一致，然后以比较字符串的方法判断两个 String 对象是否相等。==由于要求 equals 为 true 的两个对象的 hashCode 也必须相同，因此一般该方法的重写会伴随着 hashCode 方法的重写==。

	```java
	@Override
	public boolean equals(Object o) {
	    if (this == o) return true; // 先判断内存地址是否一致，相同则必然相等
	    if (o == null || getClass() != o.getClass()) return false; // 然后判断两对象的运行
	    // 时类型（getClass( )方法）是否与该对象一致，不一致就肯定不相等
	    ThisClass that = (ThisClass) o;
	    return field1 == that.field1 && // 基本数据类型字段直接判断值是否相等
	        field2.equals(that.field2) && // 引用类型则调用其各自的 equals 方法
	        field3.equals(that.field3); // field1 为基本类型，2、3为引用类型
	}
	
	@Override
	public int hashCode() { // 同时重写 hashCode 方法
	    return Objects.hash(field1, field2, field3);
	}
	```

==参考答案==：

- 首先 === = 是一个操作符== ，==equals 是超类 Object 中的方法==，==默认==是用 = = 来比较的。也就是说，对于没有重写 equals 方法的子类，equals 和 = = 是一样的。
- 而 = = 在比较时，根据所比较的类的类型不同，功能也有所不同：对于==基础数据类型==，如 int 类型等，==比较的是具体的值==；而对于==引用数据类型==，比较的是==引用的地址==是否相同。
- 对于重写的 equals 方法，比的内容==取决于这个方法的实现==。

---



### 4.讲一下equals()与hashcode()，什么时候重写，为什么重写，怎么重写？🌟🌟🌟🌟🌟

==我的回答==：

1. 首先我想说说 equals 和 hashCode 方法。它们都是 Object 类的方法。在==默认情况下，equals 方法采用 == 操作符比较引用类型的内存地址==，而 ==hashCode 方法默认情况下根据内存地址返回哈希值==。

2. 由于 equals 方法默认只能比较引用类型的内存地址，而==在业务中我们常常有自己判断两个对象是否相等的逻辑==，比如一个 Person 类有 name 和 identity 两个字段，我们可以认为这两个字段都相同的 Person 实例对象相等，于是就可以重写 Person 类的 equals 方法。

3. 由于有==规定：如果两个对象使用 equals 方法相同，那么它们的 hashCode 也必须相同==。因此 ==equals 方法的重写一般也伴随着 hashCode 方法的重写==。

4. 至于重写的方法，还是以上述的 Person 类为例，重写 equals 方法时，可以==先判断内存地址是否一致==，相同则必然相等，然后==判断两对象的运行时类型（getClass( )方法）是否与该对象一致==，不一致就肯定不相等，最后对于==基本数据类型字段直接判断值==是否相等，而==引用类型则调用其各自的 equals 方法==。

	```java
	@Override
	public boolean equals(Object o) {
	    if (this == o) return true; // 先判断内存地址是否一致，相同则必然相等
	    if (o == null || getClass() != o.getClass()) return false; // 然后判断两对象的运行
	    // 时类型（getClass( )方法）是否与该对象一致，不一致就肯定不相等
	    ThisClass that = (ThisClass) o;
	    return field1 == that.field1 && // 基本数据类型字段直接判断值是否相等
	        field2.equals(that.field2) && // 引用类型则调用其各自的 equals 方法
	        field3.equals(that.field3); // field1 为基本类型，2、3为引用类型
	}
	```

5. 重写 hashCode 方法可以使用==工具类 Objects 的 hash 方法==根据所有指定字段返回一个哈希值。

	```java
	@Override
	public int hashCode() { // 同时重写 hashCode 方法
	    return Objects.hash(field1, field2, field3);
	}
	```

==参考答案==：

- 首先 equals( ) 是 Object 中的方法，默认是用 = = 来比较的。hashCode( ) 也是 Object 类的方法，根据一定的规则将与对象相关的信息，比如对象的内存地址，映射成一个数值，这个数值称作为哈希值。
- 有时候我们想要==自定义类的比较规则时，需要重写 equals( )==，但是为了==保证类在 HashSet 和 HashMap 等集合中的正确存储，也要同时重写 hashCode( )== 。
- 以 HashMap 为例， ==HashMap底层在添加相同的元素时，会先调用两个对象的 hashCode( ) 是否相同，如果相同还会再用 equals( ) 比较两个对象是否相同==。
- 假设有一个 Person 类，有 name 和 age 两个字段，我们现在重写 equals( ) 规定只有两个 Person 的 name 和 age 都相同时，才认为两个 Person 相等。现在 new 出两个 name 和 age 都相同的 Person，分别添加到 HashMap 中。
- ==我们期望最后 HashMap 中只有一个 Person，但其实是有两个==。原因在于添加第二个 Person 时，先比较的是两个 Person 的 hashCode( )，注意此时我们==没有重写 hashCode( ) ==，那么分别 new 出来的 Person 的哈希值肯定是不同的，到这里 HashMap 就会将两个 Person 认定为不同的元素添加进去。
- 解决的办法就是重写 hashCode( )，最简单的返回 name 和 age 的哈希值的乘积即可。

---



### 5.讲一下重载和重写的区别？🌟🌟🌟🌟🌟

==我的回答==：

1. ==重载==是指在一个类中，可以==定义多个方法名相同的方法==，它们的参数个数或类型必须不同，而==返回类型对方法是否构成重载没有影响==，比如一个方法如果只有返回类型和另一个类中的方法不同，不构成重载。
2. ==重写==是指子类某个方法==覆盖了==其父类或实现的接口中的某个方法。这两个方法必须方法名，参数完全相同，==返回类型相同或子类返回类型为父类返回类型的子类==。
3. 同时，==子类重写的方法不能缩小父类方法的访问范围==。比如如果父类方法是 public，那么子类方法就只能是 public，而不能是 protected 或 private，因为这会缩小父类方法的访问范围，如果不同包下的一个类可以调用父类接口，但是==如果父类的运行时类型是子类，那么就会出现没有子类访问权限的问题==。
4. 此外，==子类还不能重写父类的 static 和 private 方法==。对于 static 方法，因为==方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的==。==static 方法跟类的任何实例都不相关==。
5. 而被 ==private 修饰的方法只能在本类中被调用==，因此==子类无法访问父类的 private 方法==，自然不能重写。

==参考答案==：

- 重载是指在同一个类中定义多个方法，它们具有相同的函数名，但参数的类型，个数和顺序可能不同。它提供了一种灵活的方式来实现相似的功能。
- 重写是指在子类中重新定义并覆盖父类中的方法。它使子类可以根据具体的类型调用相应的方法实现。
- 在 JVM 中，==方法重载对应 “静态分配” 的过程==，也就是 ==JVM 在编译期就根据参数(重载方法的参数)的静态类型，决定了会使用方法的哪个重载版本==。而==方法重写对应 “动态分配” 的过程==，具体的，重写方法的调用是由字节码中的 invokevirtual 指令实现的，而 ==invokevirtual 指令会在运行(Runtime)期间，根据方法接受者的实际类型来选择方法的执行版本==。

---



### 6.抽象和接口的区别？🌟🌟🌟🌟🌟

==我的回答==：

1. 抽象关键字 ==abstract 可以作用于类或方法==。被 abstract 修饰的方法没有方法体，其方法体由子类自行实现，因此==如果一个类存在 abstract 方法，那么它也必定是抽象类==，且==不能 new 创建实例==（因为其抽象方法没有方法体）。但是==抽象类本质上还是一个类(Class)==，它依然==可以有成员变量，构造器，静态代码块，并可以继承自或实现其它类==。
2. 接口关键字 ==interface 只能作用于类==。在 ==jdk7 及更早版本中，interface 下的所有方法都默认为 public abstract== 类型。而在 ==jdk8 及之后的版本中==，==interface 允许拥有被 static 或 default 修饰的方法==。其中==接口类中的 static 方法只能被本接口调用==。而==被 default 修饰的方法允许在接口类中定义默认的方法体，即它的实现类可以选择性地重写被 default 修饰的方法==，这一点和继承很类似，在我看来接口中 default 方法设计的初衷是对 java 单继承机制的一个补充，实际上==接口本身就是对 java 单继承机制的补充==，只不过被 default 修饰的方法与继承关系中子类重写父类方法的行为逻辑更相似。==接口类中允许存在字段，但是所有的字段都默认为 public static final== 类型，因此对于一个项目中的常量，我们可以把它们放到一个接口类中，然后所有需要使用这些常量的其它类只需实现这个接口即可安全的使用这些常量。接口类同样不能创建实例，和抽象类不同的是，==接口类不能有构造器和静态代码块==，并且==只能实现其它接口而不能继承其它类==。

==参考答案==：

- 抽象在 Java 中是指被 abstract 修饰的类或方法，接口是指被 interface 修饰的类。接口中声明的方法，默认也被定义为 abstract 。
- ==抽象主要是为了代码复用==。比如一些类拥有一些通用的功能，为了不在每一类中重新写一遍这个方法的代码，就可以定义一个抽象类，这样一来，只需让每一个类继承抽象类就可以了，如果后期需要修改方法，只需要修改抽象类中的方法就行，如果子类想要自己实现不一样的行为，只需子类重写抽象类的方法。
- 这样一来，普通类就可以完成这个工作，为什么需要抽象类，==抽象类还起了一个限制作用==，比如要求每一个子类必须自己独特实现的一个方法，也是抽象类定义的抽象方法。
- 缺点也很明显，因为Java没有多继承，导致一个类只能继承一个父类。在表示是什么的关系时，一般使用抽象类。
- ==接口更多的是为了解耦==。比如==我需要制定一套方法的规范，就可以将这套方法规范抽象为一个接口==。每一个继承这个接口的类都必须实现接口中所有的方法。在表示有什么的关系时，使用接口。

---



### 7.谈一谈你对 final 关键字的理解？什么需要用这个关键字来定义呢？🌟🌟🌟🌟

==我的回答==：

1. final 关键字可以修饰类，方法，成员变量以及局部变量。
2. 当修饰类时，该类无法被继承。比如基本类型的包装类以及 String 都被 final 修饰，它们不能被继承。
3. 当修饰方法时，表示该方法不能被子类重写。
4. 修饰成员变量时，该成员变量无法被修改，因此==必须赋初值==。当成员变量不是 static 时，可以在==初始化，构造器或普通代码块==中进行赋初值；而对于 static 成员变量，则只能在==初始化和静态代码块==中赋初值。
5. 值得注意的是，当成员变量为引用类型变量时，只是==引用变量的地址不能改变，但是放的内容可以改变==。
6. 此外，==final 不能修饰构造器==。当 ==final static 连用时，JVM 底层做了优化，不会加载类==。

==参考答案==：

- final是Java中的一个关键字，可以用来修饰类、方法、变量。
- 当用final来修饰类时，表示这个类不可以被继承，==可以确保一些安全性，防止类被纂改==。而final用来修饰方法，表示方法不可以被重写，final修饰变量时，如果是基本数据类型，值不变。
- 如果是==引用类型，引用指向的地址值不变，但地址的内容可能会变==。==final可以用来解决一些安全性问题（多态中的安全）。比如Java的一些核心类库的类的API接口不想被纂改就使用final修饰方法==。
- ==Java希望String类是不可变的，就使用final修饰String类并且修饰成员变量char[]数组，并且没有提供setter方法，这样就可以确保String类是不可变的（举例说明 final 的使用场景，解决安全性问题）==。
- 另外，如果有多个线程操作同一个变量，并且这个变量的值不会变化，可以考虑使用final修饰解决线程安全问题。

---



### 8.异常连击，按照提问逐一回答🌟🌟🌟🌟

==问题一==：==说一说你对异常的理解？==（指导：就是回答异常有啥用之类的）

==我的回答==：

1. ==程序遇到未经处理的异常时会终止，而捕获异常并处理后程序可以继续运行==。
2. 我们可以==将可能会出现错误的代码单独提出来==，当出现异常时进行捕获并处理，保障程序的正确进行并为后续维护提供帮助。比如我们在捕获到异常后可以把异常发生的位置和详细情况写到日志中，这样运维人员可以根据日志内容对程序进行排查和修复，以避免后续出现同样的异常。

==参考答案==：

- 异常是程序在执行过程中可能发生的一些错误，==它会暂时终止程序，并转到异常处理部分尝试恢复==。异常的出现可以使==我们把程序中可能出现错误的代码从正常代码中分离出来，单独进行处理==。

---

==问题二==：==异常有哪些种类，可以举几个例子吗？（指导：先回答分类，之后举几个自己经常看到的例子）==

==我的回答==：

1. ==异常类 Exception 继承自 Throwable，同样继承自 Throwable 的还有 Error 类==。==Error 是指程序遇到的无法处理的严重错误，比如 StackOverFlow Error （栈溢出） 和 OutOfMemory（OOM，内存不足）Error==。而 ==Exception 可以通过代码进行处理==。
2. ==Exception 类下的异常可以分为有 RuntimeException 和 CheckedException==。==CheckedException 为编译时异常，其在编译期就可以被 JVM 检测出来==，值得注意的是 ==CheckedException 并不是 java.lang 包下的类==，而只是作为一个分类存在。常见的编译时异常有 FileNotFoundException，ClassNotFoundException，IOException 等。
3. 而 ==RuntimeException 为运行时异常，在编译期无法被发现，只有程序运行时才会被检测到==，比如指针异常，数组越界异常，类型转换异常等。

==参考答案==：

- 类似于 Object 类，==Throwable 是所有异常的父类==。下一层分为 Error 类和 Exception 类。
- ==Error 类表示严重的错误，一般由 JVM 和底层系统引发，并且不可恢复==，例如内存溢出，class 没有主方法等。==Exception 类是可以被程序捕获和处理的异常情况==。
- Exception 再往下，按照异常的性质又分为==编译异常 CheckedException 和运行时异常 RuntimeException==。其中==编译异常在编译阶段就能被检测出==，例如 IO 异常 IOException，文件找不到异常 FileNotFoundException等。==运行时异常只有在程序运行时才能被检测出==，例如空指针异常 NullPointerException，数组下标越界 ArrayIndexOutOfBoundsException 等。

---

==问题三==：==throw 和 throws 有啥区别？直接 try catch 不好吗，为啥还要抛呢？（指导：有时候自己无法处理，必须得让调用该方法的人来处理，于是得用抛出）==

==我的回答==：

1. ==throw 是一个关键字==，用于手动抛出异常，==后面跟的是异常对象==。比如我们可以自定义一个异常，然后当业务出现某个特定错误时，我们可以人为抛出这个自定义异常，以便对其进行特定处理。
2. ==throws 是处理异常的一种方式==，它存在于方法的声明处，后面跟的是异常的类型，这些异常不会在本方法中进行处理，而是==抛给它的调用者，由调用者进行处理==。
3. try-catch 只能在本方法中处理异常，而 throws 则是将异常抛给调用者进行处理，==如果出现本方法中无法处理异常的情况，就需要用 throws 让方法的调用者尝试处理此异常==。

==参考答案==：

- ==throw 用在方法体内==，表示某个地方需要抛出一个异常，是一个具体的动作。而 ==throws 用在方法声明后面==，表示这个方法可能会抛出哪些异常，是一个声明。
- 这个需要分情况对待。首先，对于能在方法内处理的异常，可以直接用 try catch，但对于在==当前方法内无法处理的异常，我们只能选择抛出==，将它交给方法调用者去处理。其次，==有时多个方法可能会抛出相同类型的异常，如果每个方法都用 try catch 会非常冗余，这时可以在这些方法中只 throw，在调用这些方法的地方整体 try catch，统一进行处理==。
- 还有的话就是，有时候得把异常交给上层调用的人来处理。

---

==问题四==：==try catch会影响性能吗？为什么抛出异常的时候会影响性能？==

==我的回答==：

1. 如果程序==没有产生异常，则对性能几乎没有影响==。只有程序==捕获异常时才会影响性能==。
2. 程序捕获到异常的时候，会==跳转到 catch 代码块中执行处理异常的逻辑==，因此会影响性能。

==参考答案==：

- 几乎不会，也就是==程序没有异常时，try catch 加和不加性能几乎一样==，只有在程序==有异常需要捕获时才会影响性能==。
- 原因在于，==处理异常的 catch 语句在 class 文件中是用异常表实现的==。异常表有四个字段，分别是 From, To, Target 和 Type。From 和 To 分别对应 try 块对应的行号，如果其中有异常抛出，会跳转到 Target 对应的行号，也就是 catch 语句对应的位置，而这个异常的类型记录在 Type 中。如果程序在 try 中没有异常抛出，最终会通过一条 goto 指令跳转到 try catch 块后的语句继续执行，这一条 goto 指令性能的消耗可以忽略不计。==如果有异常，才会去查异常表，再跳转到对应的 catch 块位置去执行，这个过程可能会影响性能==。

---

==问题五==：==try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？==

==我的回答==：

1. ==无论是在 try 中 return 还是在 catch 中 return，finally 都会被执行==。在 catch 中 return 时，==程序会先把当前的返回值存到一个 temp 中，然后执行 finally 中的代码==。

2. 比如 catch 中返回 a，会==先把此时 a 的值赋给 temp，然后执行 finally==，那么这时候==就算 finally 中改变了 a 的值，catch 中返回值也不会变化，因为修改 a 无法影响 temp 的值==。

	```java
	public static void main(String[] args) {
	    System.out.println("the return value of f() is " + f()); // 2
	}
	
	static int f() {
	    int a = 1;
	    try {
	        throw new RuntimeException();
	    } catch (Exception e) {
	        a = 2;
	        return a;
	    } finally {
	        a = 3;
	    }
	}
	```

3. 但是，==如果在 finally 中也有 return 的话，就直接返回 finally 中的 return==，否则就会返回 temp。

	```java
	public static void main(String[] args) {
	    System.out.println("the return value of f is " + f()); // 3
	}
	
	static int f() {
	    int a = 1;
	    try {
	        throw new RuntimeException();
	    } catch (Exception e) {
	        a = 2;
	        return a;
	    } finally {
	        a = 3;
	        return a;
	    }
	}
	```

==参考答案==：

- 会的，==无论 catch 块中有异常还是有返回语句，最终一定会在方法真正结束之前执行 finally==。
- 但是需要考虑一种==特殊情况==，就是如果 ==try 块中抛出了异常但没有被 catch 捕获，且此时 finally 中也抛出了异常==，那么 ==finally 中的异常会覆盖掉 try 中的异常，成为这个方法最终抛出的异常==。实践中需要注意一下这个异常覆盖问题。

---



### 9.String 五连击按照提问逐一回答🌟🌟🌟🌟🌟

==问题一==：==String 为什么要设计为不可变类==？（指导：可以从安全性，性能等方面来考虑）

==我的回答==：

1. ==String 被 final 修饰，String 的本质是一个 char[] 字符数组，它也被 final 修饰，在堆中的地址不能改变，并且 String 没有对外提供接口改变 char[] 的内容的 api==。因此可以保证一个 String 实例对象在运行时无法改变，因此在并发条件下不用担心 String 对象的同步问题，具有线程安全性。

==参考答案==：

- 这个主要是出于==线程安全==和==性能方面==的考虑。

- 线程安全体现在，由于 String 是不可变的，==多个线程共享一个 String 时不用担心它的同步问题==；

- ==性能体现在缓存哈希值和设计常量池上==。==String 在被创建时就缓存了自己的哈希值，==

	```java
	/== Cache the hash code for the string */
	private int hash; // Default to 0
	```

	==使用时直接拿出来就行，不用重新计算==，==这使得 String 适合用来作为 Map 的 Key，可以快速获得 Key 的哈希值==，提高查找和比较的效率；除此之外，基于 String 的不可变，==Java 使用常量池来尽可能的共享相同的字符串，来节约 String 的存储空间==。具体的，当我们使用字面值==创建 String 时，会先去查它是否已经存在于常量池中，如果是则直接返回这个已存在于常量池中的字符串的引用，而不会在堆区创建新的对象==。

---

==问题二==：==String a = new String(“aa”) + “bb” “这句话创建了多少个对象？为什么？==

==我的回答==：

1. 创建了4个对象。首先在==常量池创建 "aa" 字符串常量对象==。然后==在堆区创建 String 实例对象，并使其 value 字段指向常量池中的 "aa" 字符串常量对象==。随后在==常量池创建 "bb" 字符串常量对象==。最后：

	```java
	StringBuilder builder = new StringBuilder;
	builder.append("aa");
	builder.append("bb");
	a = builder.toString(); // 在此又创建了一个 String 实例对象
	```

	将这两个字符串常量进行拼接，创建出 a 对象，共4个对象。

==参考答案==：

- 共创建了 4 个 String 对象，第一个是常量池中的对象 “aa”，如果常量池中有 “aa” 就直接返回，没有就创建并添加进常量池中。第二个是 new 出来的以 “aa” 为初始值创建的 String 对象，第三个 “bb” 同 “aa”，第四个是通过 “+” 拼接前两个对象，创建出的新 String 对象。

---

==问题三==：==String 对象最多可以存放多少个字符（长度）？（指导：可以从源码角度分析勒）==

==我的回答==：

1. String 的本质是一个 char[] 字符型数组，由于==数组的 length 字段的类型是 int，因此该字符型数组的长度最大为 $2^{31}-1$==。

2. 但是 ==JVM 字节码的常量池部分规定 CONSTANT_Utf8_info 的 length 只能用两个字节表示==：

	> ![image-20240429165532098](bgwROUND1.assets/image-20240429165532098.png)

	因此 ==String 的长度不能超过 $2^{16}-2$，否则无法通过编译==。

==参考答案==：

- String 在源码中使用 char[] 来维护字符序列的，而 ==char[] 的长度是 int 类型，所以理论上 String 的长度最大为 2^31−1== ，占用空间大约为 4 GB，不过根据实际 ==JVM 的堆内存限制，编译时，String长度最多可以是2的16次方减2==，运行时长度最多可以是2的31次方减1，意思是==可以在编译时定义一些短的字符串，运行时可以进行拼接，长一点也可以==。

---

==问题四==：==字符串常量池是放在堆中吗？==

==我的回答==：

1. ==字符串常量不是放在堆中的，而是放在方法区的常量池中==，并且在编译期生成字节码的时候便已完成。

==参考答案==：

- 不是，==Java 8 以前被放在永久代中==，==Java 8 及以后被放在方法区的元数据 metadata 中==。

---

==问题五==：==String中 “+” 和 StringBuffer 中的 append 会有性能上的差别吗？==

==我的回答==：

1. 有差别。String 中的 "+" ==本质是创建 StringBuilder 实例对象，调用其 append 方法，然后再 toString== ==在堆区创建拼接后的新的 String 实例对象，最后将其赋给变量==，这样做是因为 String 本身是不可变的，其 value 一旦初始化完成便不能改变，同时没有 setter 方法因此其内容也无法改变。
2. 而 StringBuffer 的 value 没有被 final 修饰，并且 ==StringBuffer 的父类 AbstractStringBuffer 提供了齐全的对 value CRUD 操作的 api==，因此 StringBuffer 的 append 不用创建新对象，而是==直接修改 value 字段==，因此其性能大于 String 中的 "+" 操作。

==参考答案==：

- ==String 的 “+” 效率低于 StringBuffer 的 append( )==。原因在于 ==String 是不可变类，任何对 String 的操作都会创建新的 String 对象==。而 “+” 的执行过程实际上是==先创建了一个 StringBuffer，然后调用 append( )，最后在 toString( )==。效率上肯定是不如 StringBuffer 直接 append( ) 高的。

---



### 10.聊一聊你对多态的理解？🌟🌟🌟🌟

==我的回答==：

1. ==多态允许一个对象编译时的类型和运行时的类型不一致，即父类的指针可以指向子类的实例==。==编译类型在对象创建时就已经确定，而运行时类型可以动态地绑定在子类的实体上==。
2. 多态允许对象在允许过程中向上转型和向下转型。==向上转型是指父类的引用指向了子类的实体==。父类引用可以调用父类的所有方法，但是==不能调用子类的方法，这在编译阶段就决定==了。而==父类方法的具体实现则会动态地绑定到子类上，取决于子类的具体实现==。
3. ==向下转型则是将父类的引用强制转换为子类的引用，前提是在转换前父类的引用必须指向子类的实体==。在向下转型之后，新的子类引用就可以调用子类所有的方法。
4. 值得注意的是，当==调用对象的方法时，会根据该对象的内存地址/运行时类型进行动态绑定==，而==对象的字段在调用时则没有动态绑定机制，哪里声明，就在哪里调用==。

==参考答案==：

- 多态可以理解为 “事物运行时的不同状态”，在 Java 中==具体指，通过动态绑定，在运行时根据对象的实际类型来调用对应的方法==。多态可以通过继承或者接口来实现。拿继承来说，子类必须重写父类的方法，通过向上转型，使用父类类型来调用子类对象的方法，结果是在运行时执行子类中重写的方法。
- ==实践中我的项目的支付模块就用到了多态==。具体来说，有一个基类 “支付方式 Payment”，它有一个 pay 方法，之后分别创建 “微信支付 WeChatPay” 和 “支付宝支付 AliPay” 两个类，并且都继承自 Payment 并重写 pay 方法。那么在之后的支付代码中，无论用户选择的哪种支付方式，都可以统一用 Payment 来进行具体的 pay 操作。原因是 ==Java 的动态绑定会确保这个方法在真正执行时，去调用子类中微信或者支付宝的 pay 方法==。另外，在修改具体的支付逻辑时，也只需单独去微信或者支付宝的类里面去修改，而不用动主逻辑里面的代码，体现出多态的灵活和可扩展性。
- 除了以上说的运行时多态，==我还听说过一个有争议的编译时多态，它具体指 Java 中的方法重载==，在编译期就根据已知的参数列表，决定了需要调用的方法。不过一般说多态都默认说的是运行时多态。

---



### 11.StringBuilder、StringBuffer有什么区别？🌟🌟🌟🌟🌟

==我的回答==：

1. ==StringBuffer 的底层是一个可变的 char[] 字符型数组==。和 String 不同的是，==StringBuffer 的 char[] 没有被 final 修饰==，并且 StringBuffer 的直接父类 ==AbstractStringBuffer 提供了针对 char[] 的 CRUD 方法==，它们==不需要像 String 那样遇到修改只能重新创建字符型常量和变量，并更改引用==，而是==直接修改 char[]==，从而显著提升了修改的效率。
2. 而 StringBuilder 相比于 StringBuffer，最大的不同是 ==StringBuilder 没有像 StringBuffer 那样对众多涉及char[] 修改的方法使用 synchronized 关键字加互斥锁实现线程安全==，换言之，==StringBuilder 是线程不安全的==，但也正因如此其运行效率在大多数情况下快于 StringBuffer，这使得==在单线程的环境下我们可以优先选择使用 StringBuilder 来构建 String 对象==，以谋求更高的效率。

==参考答案==：

- ==StringBuilder 和 StringBuffer 都是可变类，任何对它们的操作都不会产生新的对象==。两者的区别在于：==StringBuilder 没有加锁不是线程安全的，而 StringBuffer 大多数方法都加了 synchronized，是线程安全的，但执行效率会低点==。

- 源码中有一个细节，就是 ==StringBuffer 的 append 方法在执行真正的字符串拼接逻辑之前，会先清除 toStringCache，它是用来缓存最后一次 toString 结果的地方，主要用来加快 toString 的执行效率==。

	```java
	public synchronized StringBuffer append(StringBuffer sb) {
	    toStringCache = null; // 清空 toString 缓存
	    super.append(sb);
	    return this;
	}
	```

---



### 12.什么是序列化？什么情况下需要序列号？序列化在Java中是怎么实现的？🌟🌟

==我的回答==：

1. ==序列化是将java对象转化为二进制字节流的方法==。如果一个对象想要进行序列化，那么其类==必须实现 Serilizable 接口或 Externalizable 接口==。
2. 序列化一般用于在==向持久型数据库写入数据==，==使用 Redis 等键值对数据库进行数据缓存==，以及==网络传输中需要将对象序列化为字节流才能进行传输==。
3. 在Java中我们使用使用==对象IO流进行对象的序列化和反序列化==。比如在一个多用户即时通讯项目中，我们可以将一个==用户的 Message 对象通过 ObjectOutputStream.writeObject 方法转换为二进制流进行对象的网络传输==。而服务端在接收到此二进制流后也可以==使用 ObjectInputStream.readObject 方法将收到的二进制字节流反序列化为 Object 对象，并向下转型为所需的 Message 对象==，从而实现网络通讯。

==参考答案==：

- ==参考回答==1：
- ==序列化就是指将 Java 对象转换成二进制字节流的过程==。
- 当我们需要对某些对象进行==持久化==时，需要先对它们序列化成二进制字节序列，然后存到数据库或者内存中。或者两个 Java 进程==远程通信==时，也需要==将 Java 对象转换为字节序列才能在网络中传送==。
- 首先被序列化的对象一定需要==实现 Serializable 或 Externalizable 接口==。序列化与反序列化分别是通过 Java io 包下的 ObjectOutputStream 的 writeObject( ) 和 ObjectInputStream 的 readObject( ) 实现的。
- ==writeObject( ) 会对指定的 obj 对象进行序列化，并把得到的字节序列写到一个目标输出流中==。而 ==readObject( ) 会从一个输入流中读取字节序列，并将其反序列化成一个对象返回==。
- ==参考回答==2：
- 序列化就是把java对象，转换为字节序列。一般情况下，当需要持久化或者网络传输的时候，会用到序列化。例如：当我们需要把一个对象保存到文件里，或者通过网络传输这个对象，需要把这个对象序列化成字节序列，再操作。当从文件读取到字节序列时，需要对字节序列进行反序列化，把字节序列变回java对象，才能用java程序来操作这个对象。==前后端互传数据的时候，也一般会将对象序列化成json格式。这样可以统一数据的格式，方便前后端的开发人员进行联调==。使用序列化可以将对象还原成原来的状态。
- 实现序列化，需要让对象所属的类实现Serializable接口，==这个接口，我们不需要实现任何方法，只是告诉JVM，这个类的对象可以被序列化==，然后我们要==给这个类定义个long类型的常量serialVersionUID为1L，这个属性的意思是对象序列化的版本号，用来在反序列化的时候进行版本匹配==。==当我们修改这个类的结构时，要改一下serialVersionUID，改为跟之前的不一样的就可以了，否则会导致反序列化失败==。

---



### 13.Java 中的反射是什么意思？有哪些应用场景？有哪些优缺点？🌟🌟🌟

==我的回答==：

1. ==反射是一种根据类名动态获取类的Class对象，然后调用Class对象的方法实现业务逻辑的方法==。
1. 比如 ==Spring 框架中就大量使用了反射技术==。我们在 ==Application.xml 中配置一个 Bean 的全类名，之后 Spring 在项目启动时就根据这个全类名使用反射获取 Bean 对应的 Class 对象==，并通过 Class.newInstance 方法创建 Bean 实例。再比如我们可以==通过反射获取一个方法的 Method 对象，然后通过此 Method 对象查看该方法是否有某个注解==，并由此进一步实现业务逻辑。
1. ==反射的优点是具有高灵活性和可扩展性==，比如在上述的 Spring 框架中我们可以通过 Application.xml 统一管理所有的 Bean。==缺点是性能不如非反射操作，且存在安全风险==，比如==我们可以通过反射调用一个类的 private 方法==。

==参考答案==：

- ==反射就是在 Java 程序运行的过程中，动态获得某个类的方法变量，并调用的技术==。
- ==Spring 里面就大量用到了反射，比如通过 xml 文件获取 bean 的过程==。具体来说，在配置 bean 时需要指定类的完全限定名，之后 Spring 就会从 xml 文件中读取到这个类名，并通过反射获取到对应的类，进而调用该类的构造函数创建实例对象。
- 除此之外，==Java 的动态代理，序列化与反序列化中也用到了反射==。在我的项目中为了实现对某些接口限频，先是对这些接口加上自定义的限频注解，然后在拦截器中利用反射，判断将要执行的接口是否含有限频的注解。
- ==反射的优点就是能提高程序的灵活性和可扩展性==，比如刚说的通过 Spring 的 xml 文件来统一管理 bean 信息，同时也==简化了某些功能的实现==。==缺点主要是性能和安全问题==。==反射涉及了动态类型的解析，会有一定的性能开销，所以反射操作的效率要比那些非反射操作低==。其次，==反射可以绕过访问修饰符的限制==，对于私有成员也可以访问和修改，可能会导致安全问题。

---



### 14.什么是动态代理？有什么用？Java中可以怎么样实现动态代理？🌟🌟🌟

==我的回答==：

1. ==动态代理是在不改变原有方法的前提下，对这些方法进行功能扩展==。比如我们打印一个方法执行的用时，那么我们就可以通过创建代理对象进行实现。而在 ==Spring 框架下的 aop 面向切面编程也是通过动态代理扩展原有方法==，从而实现前置通知，后置通知，环绕通知等。
2. 实现动态代理的方法一般有两种，==java.reflect 包的 proxy 类，和 CGlib 的 enhancer==。
3. ==java.reflect 包的 proxy 是面向接口的动态代理，它要求被代理的类必须实现接口==，这也是该方法的局限性。具体操作是==创建一个类实现这些接口，通过反射获取到该对象的 Method 类，然后在 method.invoke 周围实现扩展的功能==。
4. ==CGlib 则会创建一个目标类的子类，通过重写其方法实现对原方法的功能扩展==。

==参考答案==：

- 我的理解是==动态代理，实际上就是在不改变原有代码的情况下对原有的方法增强==。对于一些方法，他们可能需要一些统一的处理逻辑，例如打印日志，这时候我们就可以==通过创建代理对象，来对原有方法进行功能上的加强==。实现动态代理有两种方式，==一种是通过jdk reflect包提供的proxy类实现，还有一种是通过cglib的enhancer实现==。
- 对于jdk proxy它是面向接口的动态代理，也就是说==只有一个类实现了接口，我们才能对它进行代理==，本质上来说就是这个==代理对象实现了被代理对象的接口，所以它只能增强接口中的方法==，具体代码逻辑是通过==重写invokationhandler的invoke方法，通过反射的方式对原有方法进行增强==。
- 对于==cglib的enhancer它是面向父类的动态代理==，也就是说它代理一个对象就是==通过继承被代理对象对原有方法增强==，这就意味着它可以增强被代理对象的所有方法，==并且由于反射机制的存在，可以获取到父类方法上的所有注解==。
- 动态代理经常出现在框架中，例如mybatis通过面向接口的动态代理，对接口进行实现。==在spring aop机制中，通过动态代理机制，对方法进行增强，aop中的前置通知，返回通知，异常通知等，都是通过在动态代理过程中，在相对原方法的不同位置执行对应逻辑而实现的==。

---



