# 1.Java系列

## 1.Java基础

### 1.介绍一下 Object 常见方法？🌟🌟🌟🌟🌟

==我的回答==：

1. Object 的常用方法包括  getClass(), equals(Object), hashCode(), toString(), notify(), notifyAll(), wait(无参/long/long, int), finalize() ，下面我将一一进行介绍。

2. getClass() 方法用于返回对象==运行时的类对象(Class对象)==。可进一步获取某一对象运行时类的信息。

	> ```java
	> /* Returns the runtime class of this {@code Object}.
	> ```

3. equals 方法==默认情况下使用 == ， 比较引用类型是否相等==。比如 String 类中就重写了此方法，优先比较两对象的地址和运行时类是否相同，随后以比较字符串的方式比较两个 String 对象。

4. hashCode  方法==在默认情况下根据对象的内存地址返回一个int整数==。

	```java
	/* This is typically implemented by converting the internal address of the object into an integer
	```

	==值得注意的是：由于 hashCode 方法可以被重写，因此其返回值不能直接和对象的内存地址挂钩==。hashCode 方法可以用于==帮助 HashMap 实现哈希映射==，但是一个对象在 HashMap 中映射的结果并不等同于其 hashCode，而是基于 hashCode 做了一层封装。

	```java
	static final int hash(Object key) {
	    int h;
	    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
	}
	```

	此外还规定：==如果两个对象使用 equals 方法得到 true 的话，那么它们的 hashCode 必须相同==。

	```java
	/* If two objects are equal according to the {@code equals(Object)} method, then calling the {@code hashCode} method on each of the two objects must produce the same integer result.
	```

	所以==一般两个方法会一同被重写==。

	```java
	@Override
	public boolean equals(Object o) {
	    if (this == o) return true; // 先判断内存地址是否一致，相同则必然相等
	    if (o == null || getClass() != o.getClass()) return false; // 然后判断两对象的运行
	    // 时类型（getClass( )方法）是否与该对象一致，不一致就肯定不相等
	    ThisClass that = (ThisClass) o;
	    return field1 == that.field1 && // 基本数据类型字段直接判断值是否相等
	        field2.equals(that.field2) && // 引用类型则调用其各自的 equals 方法
	        field3.equals(that.field3); // field1 为基本类型，2、3为引用类型
	}
	
	@Override
	public int hashCode() { // 同时重写 hashCode 方法
	    return Objects.hash(field1, field2, field3);
	}
	```

5.  toString  方法用于生成一个 String 字符串以描述一个对象。==默认情况下为==

	```java
	object.getClass().getName() + "@" + Integer.toHexString(object.hashCode())
	```

	==建议所有的类都自行实现 toString 方法==，以更友好的方式告诉程序员某个对象。

6. wait(无参/long/long, int) 方法用于==将此对象上的线程置于等待状态==，直到它被另一个线程以该对象的 notify 方法或 notifyAll() 方法唤醒。

7. notify(), notifyAll() 用于==唤醒某一对象上处于等待状态的线程==。值得注意的是， notify() 随机挑选一个线程唤醒，而另一个则唤醒全部线程。

8. finalize() 方法用于在JVM垃圾回收阶段，==当一个对象将被回收时，会先调用其 finalize() 方法==，目的是==尝试让该对象获得 GC Roots 的引用以逃过这次回收==。

==参考答案==：

- Object 类常见的方法有 toString( )，equals( ) 和 hashCode( )，wait( ) 和 notify( ) 等等。下面分别说一下：
- ==toString( ) 返回的是对象的字符串表示==，==默认为 「class 名 + @ + hashCode 的十六进制表示」==，我们一般会在子类将它重写为打印各个字段的值，==在调试和打日志中用的多==。
- ==equals( ) 和 hashCode( ) 通常用于对象之间的比较==。其中 equals( ) 用于判断两个对象是否相等，==默认使用 “= =” 判断==，hashCode( ) 用于获取对象的哈希码，==默认以对象的内存地址为参考==。在实践中，==为了保证元素在 HashMap 和 HashSet 等集合中的正确存储，通常需要将它俩一起重写==。
- wait( )，notify( ) 以及 notifyAll( ) 通常用于==线程间的协作和同步==。其中 ==wait( ) 使当前线程释放锁并进入等待状态==，直至被其它线程的 notify 或 notifyAll 唤醒。
- notify( ) 会在对该对象调用了 wait( ) 的线程中，==随机挑选一个唤醒，解除其阻塞状态==。而 notifyAll( ) 会唤醒==所有==在该对象上等待的线程。==wait( ) 搭配 notify( ) 可以实现一个简单的“生产-消费模型”：生产者线程产生消息后，调用 notify( ) 唤醒消费者。消费者被唤醒后消费消息，消费完成后调用 wait( ) 等待==。

> 参考答案里举了更多的例子，使得回答更形象具体，让面试官感觉你是真的懂并且能够正确运用，而不是只会干巴巴地背诵。

---



### 2.Java为什么被称为平台无关性语言？🌟🌟🌟🌟🌟

==我的回答==：

1. 首先我想说说==什么是平台无关性语言==。平台无关性语言是指“==一次编译，处处运行(Write once, run anywhere)==”的语言，平台无关性是java的设计者在设计java时的美好愿景。
2. Java实现“一次编译，处处运行”的方法是通过==javac编译器将Java源代码编译为的字节码==，而==不同的操作系统有不同的JVM==，==JVM将同一份字节码翻译为对应操作系统的指令集==，这样就让原本不能跨平台的Java源代码实现了平台无关性。

==参考答案==：

- 平台无关性是说，==一种语言在一台计算机上的运行不受平台的限制，一次编译，到处运行==。
- Java 语言具有平台无关性的关键在于 JVM。虽然==不同的操作系统使用不同的机器指令集来执行任务，同一份代码在不同的操作系统上可能无法直接执行==，但是 Java 源文件经过 ==javac 编译器编译后形成的二进制字节码，可以被各个操作系统的 JVM 翻译成该操作系统所需的指令集==，进而执行。这可以提高 Java 程序的可移植性，因为==只需针对不同操作系统提供对应的 JVM 即可，无需修改源代码==。

---



### 3.= =和equals有什么区别？🌟🌟🌟🌟🌟

==我的回答==：

1. ====是一个操作符==，可以比较==基本数据类型==之间和==引用数据类型==之间是否相等。而 ==equals 是 Object 类的一个方法==，==只能比较两个引用数据类型==是否相等。

2. 具体地说，====比较基本数据类型时，就直接比较值是否相等==。比如int就比较整型值是否相等，boolean就比较布尔值。而==\==比较引用数据类型时，则比较对象的内存地址是否一致==。

3. 而 ==equals 方法在 Object 方法中就是使用 == 比较两个对象是否相等==：

	```java
	public boolean equals(Object obj) {
	    return (this == obj);
	}
	```

	但是==我们可以根据不同对象的意义重写此方法==，以自定义的方式判断两个对象是否相等。比如 String 类就重写了 equals 方法，优先判断两个对象的内存地址和运行时类型是否一致，然后以比较字符串的方法判断两个 String 对象是否相等。==由于要求 equals 为 true 的两个对象的 hashCode 也必须相同，因此一般该方法的重写会伴随着 hashCode 方法的重写==。

	```java
	@Override
	public boolean equals(Object o) {
	    if (this == o) return true; // 先判断内存地址是否一致，相同则必然相等
	    if (o == null || getClass() != o.getClass()) return false; // 然后判断两对象的运行
	    // 时类型（getClass( )方法）是否与该对象一致，不一致就肯定不相等
	    ThisClass that = (ThisClass) o;
	    return field1 == that.field1 && // 基本数据类型字段直接判断值是否相等
	        field2.equals(that.field2) && // 引用类型则调用其各自的 equals 方法
	        field3.equals(that.field3); // field1 为基本类型，2、3为引用类型
	}
	
	@Override
	public int hashCode() { // 同时重写 hashCode 方法
	    return Objects.hash(field1, field2, field3);
	}
	```

==参考答案==：

- 首先 === = 是一个操作符== ，==equals 是超类 Object 中的方法==，==默认==是用 = = 来比较的。也就是说，对于没有重写 equals 方法的子类，equals 和 = = 是一样的。
- 而 = = 在比较时，根据所比较的类的类型不同，功能也有所不同：对于==基础数据类型==，如 int 类型等，==比较的是具体的值==；而对于==引用数据类型==，比较的是==引用的地址==是否相同。
- 对于重写的 equals 方法，比的内容==取决于这个方法的实现==。

---



### 4.讲一下equals()与hashcode()，什么时候重写，为什么重写，怎么重写？🌟🌟🌟🌟🌟

==我的回答==：

1. 首先我想说说 equals 和 hashCode 方法。它们都是 Object 类的方法。在==默认情况下，equals 方法采用 == 操作符比较引用类型的内存地址==，而 ==hashCode 方法默认情况下根据内存地址返回哈希值==。

2. 由于 equals 方法默认只能比较引用类型的内存地址，而==在业务中我们常常有自己判断两个对象是否相等的逻辑==，比如一个 Person 类有 name 和 identity 两个字段，我们可以认为这两个字段都相同的 Person 实例对象相等，于是就可以重写 Person 类的 equals 方法。

3. 由于有==规定：如果两个对象使用 equals 方法相同，那么它们的 hashCode 也必须相同==。因此 ==equals 方法的重写一般也伴随着 hashCode 方法的重写==。

4. 至于重写的方法，还是以上述的 Person 类为例，重写 equals 方法时，可以==先判断内存地址是否一致==，相同则必然相等，然后==判断两对象的运行时类型（getClass( )方法）是否与该对象一致==，不一致就肯定不相等，最后对于==基本数据类型字段直接判断值==是否相等，而==引用类型则调用其各自的 equals 方法==。

	```java
	@Override
	public boolean equals(Object o) {
	    if (this == o) return true; // 先判断内存地址是否一致，相同则必然相等
	    if (o == null || getClass() != o.getClass()) return false; // 然后判断两对象的运行
	    // 时类型（getClass( )方法）是否与该对象一致，不一致就肯定不相等
	    ThisClass that = (ThisClass) o;
	    return field1 == that.field1 && // 基本数据类型字段直接判断值是否相等
	        field2.equals(that.field2) && // 引用类型则调用其各自的 equals 方法
	        field3.equals(that.field3); // field1 为基本类型，2、3为引用类型
	}
	```

5. 重写 hashCode 方法可以使用==工具类 Objects 的 hash 方法==根据所有指定字段返回一个哈希值。

	```java
	@Override
	public int hashCode() { // 同时重写 hashCode 方法
	    return Objects.hash(field1, field2, field3);
	}
	```

==参考答案==：

- 首先 equals( ) 是 Object 中的方法，默认是用 = = 来比较的。hashCode( ) 也是 Object 类的方法，根据一定的规则将与对象相关的信息，比如对象的内存地址，映射成一个数值，这个数值称作为哈希值。
- 有时候我们想要==自定义类的比较规则时，需要重写 equals( )==，但是为了==保证类在 HashSet 和 HashMap 等集合中的正确存储，也要同时重写 hashCode( )== 。
- 以 HashMap 为例， ==HashMap底层在添加相同的元素时，会先调用两个对象的 hashCode( ) 是否相同，如果相同还会再用 equals( ) 比较两个对象是否相同==。
- 假设有一个 Person 类，有 name 和 age 两个字段，我们现在重写 equals( ) 规定只有两个 Person 的 name 和 age 都相同时，才认为两个 Person 相等。现在 new 出两个 name 和 age 都相同的 Person，分别添加到 HashMap 中。
- ==我们期望最后 HashMap 中只有一个 Person，但其实是有两个==。原因在于添加第二个 Person 时，先比较的是两个 Person 的 hashCode( )，注意此时我们==没有重写 hashCode( ) ==，那么分别 new 出来的 Person 的哈希值肯定是不同的，到这里 HashMap 就会将两个 Person 认定为不同的元素添加进去。
- 解决的办法就是重写 hashCode( )，最简单的返回 name 和 age 的哈希值的乘积即可。

---



### 5.讲一下重载和重写的区别？🌟🌟🌟🌟🌟

==我的回答==：

1. ==重载==是指在一个类中，可以==定义多个方法名相同的方法==，它们的参数个数或类型必须不同，而==返回类型对方法是否构成重载没有影响==，比如一个方法如果只有返回类型和另一个类中的方法不同，不构成重载。
2. ==重写==是指子类某个方法==覆盖了==其父类或实现的接口中的某个方法。这两个方法必须方法名，参数完全相同，==返回类型相同或子类返回类型为父类返回类型的子类==。
3. 同时，==子类重写的方法不能缩小父类方法的访问范围==。比如如果父类方法是 public，那么子类方法就只能是 public，而不能是 protected 或 private，因为这会缩小父类方法的访问范围，如果不同包下的一个类可以调用父类接口，但是==如果父类的运行时类型是子类，那么就会出现没有子类访问权限的问题==。
4. 此外，==子类还不能重写父类的 static 和 private 方法==。对于 static 方法，因为==方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的==。==static 方法跟类的任何实例都不相关==。
5. 而被 ==private 修饰的方法只能在本类中被调用==，因此==子类无法访问父类的 private 方法==，自然不能重写。

==参考答案==：

- 重载是指在同一个类中定义多个方法，它们具有相同的函数名，但参数的类型，个数和顺序可能不同。它提供了一种灵活的方式来实现相似的功能。
- 重写是指在子类中重新定义并覆盖父类中的方法。它使子类可以根据具体的类型调用相应的方法实现。
- 在 JVM 中，==方法重载对应 “静态分配” 的过程==，也就是 ==JVM 在编译期就根据参数(重载方法的参数)的静态类型，决定了会使用方法的哪个重载版本==。而==方法重写对应 “动态分配” 的过程==，具体的，重写方法的调用是由字节码中的 invokevirtual 指令实现的，而 ==invokevirtual 指令会在运行(Runtime)期间，根据方法接受者的实际类型来选择方法的执行版本==。

---



### 6.抽象和接口的区别？🌟🌟🌟🌟🌟

==我的回答==：

1. 抽象关键字 ==abstract 可以作用于类或方法==。被 abstract 修饰的方法没有方法体，其方法体由子类自行实现，因此==如果一个类存在 abstract 方法，那么它也必定是抽象类==，且==不能 new 创建实例==（因为其抽象方法没有方法体）。但是==抽象类本质上还是一个类(Class)==，它依然==可以有成员变量，构造器，静态代码块，并可以继承自或实现其它类==。
2. 接口关键字 ==interface 只能作用于类==。在 ==jdk7 及更早版本中，interface 下的所有方法都默认为 public abstract== 类型。而在 ==jdk8 及之后的版本中==，==interface 允许拥有被 static 或 default 修饰的方法==。其中==接口类中的 static 方法只能被本接口调用==。而==被 default 修饰的方法允许在接口类中定义默认的方法体，即它的实现类可以选择性地重写被 default 修饰的方法==，这一点和继承很类似，在我看来接口中 default 方法设计的初衷是对 java 单继承机制的一个补充，实际上==接口本身就是对 java 单继承机制的补充==，只不过被 default 修饰的方法与继承关系中子类重写父类方法的行为逻辑更相似。==接口类中允许存在字段，但是所有的字段都默认为 public static final== 类型，因此对于一个项目中的常量，我们可以把它们放到一个接口类中，然后所有需要使用这些常量的其它类只需实现这个接口即可安全的使用这些常量。接口类同样不能创建实例，和抽象类不同的是，==接口类不能有构造器和静态代码块==，并且==只能实现其它接口而不能继承其它类==。

==参考答案==：

- 抽象在 Java 中是指被 abstract 修饰的类或方法，接口是指被 interface 修饰的类。接口中声明的方法，默认也被定义为 abstract 。
- ==抽象主要是为了代码复用==。比如一些类拥有一些通用的功能，为了不在每一类中重新写一遍这个方法的代码，就可以定义一个抽象类，这样一来，只需让每一个类继承抽象类就可以了，如果后期需要修改方法，只需要修改抽象类中的方法就行，如果子类想要自己实现不一样的行为，只需子类重写抽象类的方法。
- 这样一来，普通类就可以完成这个工作，为什么需要抽象类，==抽象类还起了一个限制作用==，比如要求每一个子类必须自己独特实现的一个方法，也是抽象类定义的抽象方法。
- 缺点也很明显，因为Java没有多继承，导致一个类只能继承一个父类。在表示是什么的关系时，一般使用抽象类。
- ==接口更多的是为了解耦==。比如==我需要制定一套方法的规范，就可以将这套方法规范抽象为一个接口==。每一个继承这个接口的类都必须实现接口中所有的方法。在表示有什么的关系时，使用接口。

---



### 7.谈一谈你对 final 关键字的理解？什么需要用这个关键字来定义呢？🌟🌟🌟🌟

==我的回答==：

1. final 关键字可以修饰类，方法，成员变量以及局部变量。
2. 当修饰类时，该类无法被继承。==比如基本类型的包装类以及 String 都被 final 修饰，它们不能被继承，因此在实际的业务中我们不同担心在调用这些类的方法时会动态绑定到其它类==，因为它们不能被继承，也就没有子类了，因此==我们可以把业务中的核心类设置为 final，以提高安全性==。
3. 当修饰方法时，表示该方法不能被子类重写。类似的，==把核心 api 设置为 final，避免运行时动态绑定==。
4. 修饰成员变量时，该成员变量无法被修改，因此==必须赋初值==。当成员变量不是 static 时，可以在==初始化，构造器或普通代码块==中进行赋初值；而对于 static 成员变量，则只能在==初始化和静态代码块==中赋初值。
5. 值得注意的是，当成员变量为引用类型变量时，只是==引用变量的地址不能改变，但是放的内容可以改变==。
6. 此外，==final 不能修饰构造器==。当 ==final static 连用时，JVM 底层做了优化，不会加载类==。

==参考答案==：

- final是Java中的一个关键字，可以用来修饰类、方法、变量。
- 当用final来修饰类时，表示这个类不可以被继承，==可以确保一些安全性，防止类被纂改==。而final用来修饰方法，表示方法不可以被重写，final修饰变量时，如果是基本数据类型，值不变。
- 如果是==引用类型，引用指向的地址值不变，但地址的内容可能会变==。==final可以用来解决一些安全性问题（多态中的安全）。比如Java的一些核心类库的类的API接口不想被纂改就使用final修饰方法==。
- ==Java希望String类是不可变的，就使用final修饰String类并且修饰成员变量char[]数组，并且没有提供setter方法，这样就可以确保String类是不可变的（举例说明 final 的使用场景，解决安全性问题）==。
- 另外，如果有多个线程操作同一个变量，并且这个变量的值不会变化，可以考虑使用final修饰解决线程安全问题。

---



### 8.异常连击，按照提问逐一回答🌟🌟🌟🌟

==问题一==：==说一说你对异常的理解？==（指导：就是回答异常有啥用之类的）

==我的回答==：

1. ==程序遇到未经处理的异常时会终止，而捕获异常并处理后程序可以继续运行==。
2. 我们可以==将可能会出现错误的代码单独提出来==，当出现异常时进行捕获并处理，保障程序的正确进行并为后续维护提供帮助。比如我们在捕获到异常后可以把异常发生的位置和详细情况写到日志中，这样运维人员可以根据日志内容对程序进行排查和修复，以避免后续出现同样的异常。

==参考答案==：

- 异常是程序在执行过程中可能发生的一些错误，==它会暂时终止程序，并转到异常处理部分尝试恢复==。异常的出现可以使==我们把程序中可能出现错误的代码从正常代码中分离出来，单独进行处理==。

---

==问题二==：==异常有哪些种类，可以举几个例子吗？（指导：先回答分类，之后举几个自己经常看到的例子）==

==我的回答==：

1. ==异常类 Exception 继承自 Throwable，同样继承自 Throwable 的还有 Error 类==。==Error 是指程序遇到的无法处理的严重错误，比如 StackOverFlow Error （栈溢出） 和 OutOfMemory（OOM，内存不足）Error==。而 ==Exception 可以通过代码进行处理==。
2. ==Exception 类下的异常可以分为有 RuntimeException 和 CheckedException==。==CheckedException 为编译时异常，其在编译期就可以被 JVM 检测出来==，值得注意的是 ==CheckedException 并不是 java.lang 包下的类==，而只是作为一个分类存在。常见的编译时异常有 FileNotFoundException，ClassNotFoundException，IOException 等。
3. 而 ==RuntimeException 为运行时异常，在编译期无法被发现，只有程序运行时才会被检测到==，比如指针异常，数组越界异常，类型转换异常等。

==参考答案==：

- 类似于 Object 类，==Throwable 是所有异常的父类==。下一层分为 Error 类和 Exception 类。
- ==Error 类表示严重的错误，一般由 JVM 和底层系统引发，并且不可恢复==，例如内存溢出，class 没有主方法等。==Exception 类是可以被程序捕获和处理的异常情况==。
- Exception 再往下，按照异常的性质又分为==编译异常 CheckedException 和运行时异常 RuntimeException==。其中==编译异常在编译阶段就能被检测出==，例如 IO 异常 IOException，文件找不到异常 FileNotFoundException等。==运行时异常只有在程序运行时才能被检测出==，例如空指针异常 NullPointerException，数组下标越界 ArrayIndexOutOfBoundsException 等。

---

==问题三==：==throw 和 throws 有啥区别？直接 try catch 不好吗，为啥还要抛呢？（指导：有时候自己无法处理，必须得让调用该方法的人来处理，于是得用抛出）==

==我的回答==：

1. ==throw 是一个关键字==，用于手动抛出异常，==后面跟的是异常对象==。比如我们可以自定义一个异常，然后当业务出现某个特定错误时，我们可以人为抛出这个自定义异常，以便对其进行特定处理。
2. ==throws 是处理异常的一种方式==，它存在于方法的声明处，后面跟的是异常的类型，这些异常不会在本方法中进行处理，而是==抛给它的调用者，由调用者进行处理==。
3. try-catch 只能在本方法中处理异常，而 throws 则是将异常抛给调用者进行处理，==如果出现本方法中无法处理异常的情况，就需要用 throws 让方法的调用者尝试处理此异常==。

==参考答案==：

- ==throw 用在方法体内==，表示某个地方需要抛出一个异常，是一个具体的动作。而 ==throws 用在方法声明后面==，表示这个方法可能会抛出哪些异常，是一个声明。
- 这个需要分情况对待。首先，对于能在方法内处理的异常，可以直接用 try catch，但对于在==当前方法内无法处理的异常，我们只能选择抛出==，将它交给方法调用者去处理。其次，==有时多个方法可能会抛出相同类型的异常，如果每个方法都用 try catch 会非常冗余，这时可以在这些方法中只 throw，在调用这些方法的地方整体 try catch，统一进行处理==。
- 还有的话就是，有时候得把异常交给上层调用的人来处理。

---

==问题四==：==try catch会影响性能吗？为什么抛出异常的时候会影响性能？==

==我的回答==：

1. 如果程序==没有产生异常，则对性能几乎没有影响==。只有程序==捕获异常时才会影响性能==。
2. 程序捕获到异常的时候，会==跳转到 catch 代码块中执行处理异常的逻辑==，因此会影响性能。

==参考答案==：

- 几乎不会，也就是==程序没有异常时，try catch 加和不加性能几乎一样==，只有在程序==有异常需要捕获时才会影响性能==。
- 原因在于，==处理异常的 catch 语句在 class 文件中是用异常表实现的==。异常表有四个字段，分别是 From, To, Target 和 Type。From 和 To 分别对应 try 块对应的行号，如果其中有异常抛出，会跳转到 Target 对应的行号，也就是 catch 语句对应的位置，而这个异常的类型记录在 Type 中。如果程序在 try 中没有异常抛出，最终会通过一条 goto 指令跳转到 try catch 块后的语句继续执行，这一条 goto 指令性能的消耗可以忽略不计。==如果有异常，才会去查异常表，再跳转到对应的 catch 块位置去执行，这个过程可能会影响性能==。

---

==问题五==：==try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？==

==我的回答==：

1. ==无论是在 try 中 return 还是在 catch 中 return，finally 都会被执行==。在 catch 中 return 时，==程序会先把当前的返回值存到一个 temp 中，然后执行 finally 中的代码==。

2. 比如 catch 中返回 a，会==先把此时 a 的值赋给 temp，然后执行 finally==，那么这时候==就算 finally 中改变了 a 的值，catch 中返回值也不会变化，因为修改 a 无法影响 temp 的值==。

	```java
	public static void main(String[] args) {
	    System.out.println("the return value of f() is " + f()); // 2
	}
	
	static int f() {
	    int a = 1;
	    try {
	        throw new RuntimeException();
	    } catch (RuntimeException e) {
	        a = 2;
	        return a;
	    } finally {
	        a = 3;
	    }
	}
	```

3. 但是，==如果在 finally 中也有 return 的话，就直接返回 finally 中的 return==，否则就会返回 temp。

	```java
	public static void main(String[] args) {
	    System.out.println("the return value of f is " + f()); // 3
	}
	
	static int f() {
	    int a = 1;
	    try {
	        throw new RuntimeException();
	    } catch (RuntimeException e) {
	        a = 2;
	        return a;
	    } finally {
	        a = 3;
	        return a;
	    }
	}
	```

==参考答案==：

- 会的，==无论 catch 块中有异常还是有返回语句，最终一定会在方法真正结束之前执行 finally==。
- 但是需要考虑一种==特殊情况==，就是如果 ==try 块中抛出了异常但没有被 catch 捕获，且此时 finally 中也抛出了异常==，那么 ==finally 中的异常会覆盖掉 try 中的异常，成为这个方法最终抛出的异常==。实践中需要注意一下这个异常覆盖问题。

---



### 9.String 五连击按照提问逐一回答🌟🌟🌟🌟🌟

==问题一==：==String 为什么要设计为不可变类==？（指导：可以从安全性，性能等方面来考虑）

==我的回答==：

1. ==String 被 final 修饰，String 的本质是一个 char[] 字符数组，它也被 final 修饰，在堆中的地址不能改变，并且 String 没有对外提供接口改变 char[] 的内容的 api==。因此可以保证一个 String 实例对象在运行时无法改变，因此在并发条件下不用担心 String 对象的同步问题，具有线程安全性。

==参考答案==：

- 这个主要是出于==线程安全==和==性能方面==的考虑。

- 线程安全体现在，由于 String 是不可变的，==多个线程共享一个 String 时不用担心它的同步问题==；

- ==性能体现在缓存哈希值和设计常量池上==。==String 在被创建时就缓存了自己的哈希值，==

	```java
	/== Cache the hash code for the string */
	private int hash; // Default to 0
	```

	==使用时直接拿出来就行，不用重新计算==，==这使得 String 适合用来作为 Map 的 Key，可以快速获得 Key 的哈希值==，提高查找和比较的效率；除此之外，基于 String 的不可变，==Java 使用常量池来尽可能的共享相同的字符串，来节约 String 的存储空间==。具体的，当我们使用字面值==创建 String 时，会先去查它是否已经存在于常量池中，如果是则直接返回这个已存在于常量池中的字符串的引用，而不会在堆区创建新的对象==。

---

==问题二==：==String a = new String(“aa”) + “bb” “这句话创建了多少个对象？为什么？==

==我的回答==：

1. 创建了4个对象。首先在==常量池创建 "aa" 字符串常量对象==。然后==在堆区创建 String 实例对象，并使其 value 字段指向常量池中的 "aa" 字符串常量对象==。随后在==常量池创建 "bb" 字符串常量对象==。最后：

	```java
	StringBuilder builder = new StringBuilder;
	builder.append("aa");
	builder.append("bb");
	a = builder.toString(); // 在此又创建了一个 String 实例对象
	```

	将这两个字符串常量进行拼接，创建出 a 对象，共4个对象。

==参考答案==：

- 共创建了 4 个 String 对象，第一个是常量池中的对象 “aa”，如果常量池中有 “aa” 就直接返回，没有就创建并添加进常量池中。第二个是 new 出来的以 “aa” 为初始值创建的 String 对象，第三个 “bb” 同 “aa”，第四个是通过 “+” 拼接前两个对象，创建出的新 String 对象。

---

==问题三==：==String 对象最多可以存放多少个字符（长度）？（指导：可以从源码角度分析勒）==

==我的回答==：

1. String 的本质是一个 char[] 字符型数组，由于==数组的 length 字段的类型是 int，因此该字符型数组的长度最大为 $2^{31}-1$==。

2. 但是 ==JVM 字节码的常量池部分规定 CONSTANT_Utf8_info 的 length 只能用两个字节表示==：

	> ![image-20240429165532098](bgwROUND1.assets/image-20240429165532098.png)

	因此 ==String 的长度不能超过 $2^{16}-2$，否则无法通过编译==。

==参考答案==：

- String 在源码中使用 char[] 来维护字符序列的，而 ==char[] 的长度是 int 类型，所以理论上 String 的长度最大为 2^31−1== ，占用空间大约为 4 GB，不过根据实际 ==JVM 的堆内存限制，编译时，String长度最多可以是2的16次方减2==，运行时长度最多可以是2的31次方减1，意思是==可以在编译时定义一些短的字符串，运行时可以进行拼接，长一点也可以==。

---

==问题四==：==字符串常量池是放在堆中吗？==

==我的回答==：

1. ==字符串常量不是放在堆中的，而是放在方法区的常量池中==，并且在编译期生成字节码的时候便已完成。

==参考答案==：

- 不是，==Java 8 以前被放在永久代中==，==Java 8 及以后被放在方法区的元数据 metadata 中==。

---

==问题五==：==String中 “+” 和 StringBuffer 中的 append 会有性能上的差别吗？==

==我的回答==：

1. 有差别。String 中的 "+" ==本质是创建 StringBuilder 实例对象，调用其 append 方法，然后再 toString== ==在堆区创建拼接后的新的 String 实例对象，最后将其赋给变量==，这样做是因为 String 本身是不可变的，其 value 一旦初始化完成便不能改变，同时没有 setter 方法因此其内容也无法改变。
2. 而 StringBuffer 的 value 没有被 final 修饰，并且 ==StringBuffer 的父类 AbstractStringBuffer 提供了齐全的对 value CRUD 操作的 api==，因此 StringBuffer 的 append 不用创建新对象，而是==直接修改 value 字段==，因此其性能大于 String 中的 "+" 操作。

==参考答案==：

- ==String 的 “+” 效率低于 StringBuffer 的 append( )==。原因在于 ==String 是不可变类，任何对 String 的操作都会创建新的 String 对象==。而 “+” 的执行过程实际上是==先创建了一个 StringBuffer，然后调用 append( )，最后在 toString( )==。效率上肯定是不如 StringBuffer 直接 append( ) 高的。

---



### 10.聊一聊你对多态的理解？🌟🌟🌟🌟

==我的回答==：

1. ==多态允许一个对象编译时的类型和运行时的类型不一致，即父类的指针可以指向子类的实例==。==编译类型在对象创建时就已经确定，而运行时类型可以动态地绑定在子类的实体上==。
2. 多态允许对象在允许过程中向上转型和向下转型。==向上转型是指父类的引用指向了子类的实体==。父类引用可以调用父类的所有方法，但是==不能调用子类的方法，这在编译阶段就决定==了。而==父类方法的具体实现则会动态地绑定到子类上，取决于子类的具体实现==。
3. ==向下转型则是将父类的引用强制转换为子类的引用，前提是在转换前父类的引用必须指向子类的实体==。在向下转型之后，新的子类引用就可以调用子类所有的方法。
4. 值得注意的是，当==调用对象的方法时，会根据该对象的内存地址/运行时类型进行动态绑定==，而==对象的字段在调用时则没有动态绑定机制，哪里声明，就在哪里调用==。

==参考答案==：

- 多态可以理解为 “事物运行时的不同状态”，在 Java 中==具体指，通过动态绑定，在运行时根据对象的实际类型来调用对应的方法==。多态可以通过继承或者接口来实现。拿继承来说，子类必须重写父类的方法，通过向上转型，使用父类类型来调用子类对象的方法，结果是在运行时执行子类中重写的方法。
- ==实践中我的项目的支付模块就用到了多态==。具体来说，有一个基类 “支付方式 Payment”，它有一个 pay 方法，之后分别创建 “微信支付 WeChatPay” 和 “支付宝支付 AliPay” 两个类，并且都继承自 Payment 并重写 pay 方法。那么在之后的支付代码中，无论用户选择的哪种支付方式，都可以统一用 Payment 来进行具体的 pay 操作。原因是 ==Java 的动态绑定会确保这个方法在真正执行时，去调用子类中微信或者支付宝的 pay 方法==。另外，在修改具体的支付逻辑时，也只需单独去微信或者支付宝的类里面去修改，而不用动主逻辑里面的代码，体现出多态的灵活和可扩展性。
- 除了以上说的运行时多态，==我还听说过一个有争议的编译时多态，它具体指 Java 中的方法重载==，在编译期就根据已知的参数列表，决定了需要调用的方法。不过一般说多态都默认说的是运行时多态。

---



### 11.StringBuilder、StringBuffer有什么区别？🌟🌟🌟🌟🌟

==我的回答==：

1. ==StringBuffer 的底层是一个可变的 char[] 字符型数组==。和 String 不同的是，==StringBuffer 的 char[] 没有被 final 修饰==，并且 StringBuffer 的直接父类 ==AbstractStringBuffer 提供了针对 char[] 的 CRUD 方法==，它们==不需要像 String 那样遇到修改只能重新创建字符型常量和变量，并更改引用==，而是==直接修改 char[]==，从而显著提升了修改的效率。
2. 而 StringBuilder 相比于 StringBuffer，最大的不同是 ==StringBuilder 没有像 StringBuffer 那样对众多涉及char[] 修改的方法使用 synchronized 关键字加互斥锁实现线程安全==，换言之，==StringBuilder 是线程不安全的==，但也正因如此其运行效率在大多数情况下快于 StringBuffer，这使得==在单线程的环境下我们可以优先选择使用 StringBuilder 来构建 String 对象==，以谋求更高的效率。

==参考答案==：

- ==StringBuilder 和 StringBuffer 都是可变类，任何对它们的操作都不会产生新的对象==。两者的区别在于：==StringBuilder 没有加锁不是线程安全的，而 StringBuffer 大多数方法都加了 synchronized，是线程安全的，但执行效率会低点==。

- 源码中有一个细节，就是 ==StringBuffer 的 append 方法在执行真正的字符串拼接逻辑之前，会先清除 toStringCache，它是用来缓存最后一次 toString 结果的地方，主要用来加快 toString 的执行效率==。

	```java
	public synchronized StringBuffer append(StringBuffer sb) {
	    toStringCache = null; // 清空 toString 缓存
	    super.append(sb);
	    return this;
	}
	```

---



### 12.什么是序列化？什么情况下需要序列号？序列化在Java中是怎么实现的？🌟🌟

==我的回答==：

1. ==序列化是将java对象转化为二进制字节流的方法==。如果一个对象想要进行序列化，那么其类==必须实现 Serilizable 接口或 Externalizable 接口==。
2. 序列化一般用于在==向持久型数据库写入数据==，==使用 Redis 等键值对数据库进行数据缓存==，以及==网络传输中需要将对象序列化为字节流才能进行传输==。
3. 在Java中我们使用使用==对象IO流进行对象的序列化和反序列化==。比如在一个多用户即时通讯项目中，我们可以将一个==用户的 Message 对象通过 ObjectOutputStream.writeObject 方法转换为二进制流进行对象的网络传输==。而服务端在接收到此二进制流后也可以==使用 ObjectInputStream.readObject 方法将收到的二进制字节流反序列化为 Object 对象，并向下转型为所需的 Message 对象==，从而实现网络通讯。

==参考答案==：

- ==参考回答==1：
- ==序列化就是指将 Java 对象转换成二进制字节流的过程==。
- 当我们需要对某些对象进行==持久化==时，需要先对它们序列化成二进制字节序列，然后存到数据库或者内存中。或者两个 Java 进程==远程通信==时，也需要==将 Java 对象转换为字节序列才能在网络中传送==。
- 首先被序列化的对象一定需要==实现 Serializable 或 Externalizable 接口==。序列化与反序列化分别是通过 Java io 包下的 ObjectOutputStream 的 writeObject( ) 和 ObjectInputStream 的 readObject( ) 实现的。
- ==writeObject( ) 会对指定的 obj 对象进行序列化，并把得到的字节序列写到一个目标输出流中==。而 ==readObject( ) 会从一个输入流中读取字节序列，并将其反序列化成一个对象返回==。
- ==参考回答==2：
- 序列化就是把java对象，转换为字节序列。一般情况下，当需要持久化或者网络传输的时候，会用到序列化。例如：当我们需要把一个对象保存到文件里，或者通过网络传输这个对象，需要把这个对象序列化成字节序列，再操作。当从文件读取到字节序列时，需要对字节序列进行反序列化，把字节序列变回java对象，才能用java程序来操作这个对象。==前后端互传数据的时候，也一般会将对象序列化成json格式。这样可以统一数据的格式，方便前后端的开发人员进行联调==。使用序列化可以将对象还原成原来的状态。
- 实现序列化，需要让对象所属的类实现Serializable接口，==这个接口，我们不需要实现任何方法，只是告诉JVM，这个类的对象可以被序列化==，然后我们要==给这个类定义个long类型的常量serialVersionUID为1L，这个属性的意思是对象序列化的版本号，用来在反序列化的时候进行版本匹配==。==当我们修改这个类的结构时，要改一下serialVersionUID，改为跟之前的不一样的就可以了，否则会导致反序列化失败==。

---



### 13.Java 中的反射是什么意思？有哪些应用场景？有哪些优缺点？🌟🌟🌟

==我的回答==：

1. ==反射是一种在运行时动态获取类的Class对象，然后调用Class对象的方法实现业务逻辑的技术==。
1. 比如 ==Spring 框架中就大量使用了反射技术==。我们在 ==Application.xml 中配置一个 Bean 的全类名，之后 Spring 在项目启动时就根据这个全类名使用反射获取 Bean 对应的 Class 对象==，并通过 Class.newInstance 方法创建 Bean 实例。再比如我们可以==通过反射获取一个方法的 Method 对象，然后通过此 Method 对象查看该方法是否有某个注解==，并由此进一步实现业务逻辑。
1. ==反射的优点是具有高灵活性和可扩展性==，比如在上述的 Spring 框架中我们可以通过 Application.xml 统一管理所有的 Bean。==缺点是性能不如非反射操作，且存在安全风险==，比如==我们可以通过反射调用一个类的 private 方法==。

==参考答案==：

- ==反射就是在 Java 程序运行的过程中，动态获得某个类的方法变量，并调用的技术==。
- ==Spring 里面就大量用到了反射，比如通过 xml 文件获取 bean 的过程==。具体来说，在配置 bean 时需要指定类的完全限定名，之后 Spring 就会从 xml 文件中读取到这个类名，并通过反射获取到对应的类，进而调用该类的构造函数创建实例对象。
- 除此之外，==Java 的动态代理，序列化与反序列化中也用到了反射==。在我的项目中为了实现对某些接口限频，先是对这些接口加上自定义的限频注解，然后在拦截器中利用反射，判断将要执行的接口是否含有限频的注解。
- ==反射的优点就是能提高程序的灵活性和可扩展性==，比如刚说的通过 Spring 的 xml 文件来统一管理 bean 信息，同时也==简化了某些功能的实现==。==缺点主要是性能和安全问题==。==反射涉及了动态类型的解析，会有一定的性能开销，所以反射操作的效率要比那些非反射操作低==。其次，==反射可以绕过访问修饰符的限制==，对于私有成员也可以访问和修改，可能会导致安全问题。

---



### 14.什么是动态代理？有什么用？Java中可以怎么样实现动态代理？🌟🌟🌟

==我的回答==：

1. ==动态代理是在不改变原有方法的前提下，对这些方法进行功能扩展==。比如我们打印一个方法执行的用时，那么我们就可以通过创建代理对象进行实现。而在 ==Spring 框架下的 aop 面向切面编程也是通过动态代理扩展原有方法==，从而实现前置通知，后置通知，环绕通知等。
2. 实现动态代理的方法一般有两种，==java.reflect 包的 proxy 类，和 CGlib 的 enhancer==。
3. ==java.reflect 包的 proxy 是面向接口的动态代理，它要求被代理的类必须实现接口==，这也是该方法的局限性。具体操作是==创建一个类实现这些接口，通过反射获取到该对象的 Method 类，然后在 method.invoke 周围实现扩展的功能==。
4. ==CGlib 则会创建一个目标类的子类，通过重写其方法实现对原方法的功能扩展==。

==参考答案==：

- 我的理解是==动态代理，实际上就是在不改变原有代码的情况下对原有的方法增强==。对于一些方法，他们可能需要一些统一的处理逻辑，例如打印日志，这时候我们就可以==通过创建代理对象，来对原有方法进行功能上的加强==。实现动态代理有两种方式，==一种是通过jdk reflect包提供的proxy类实现，还有一种是通过cglib的enhancer实现==。
- 对于jdk proxy它是面向接口的动态代理，也就是说==只有一个类实现了接口，我们才能对它进行代理==，本质上来说就是这个==代理对象实现了被代理对象的接口，所以它只能增强接口中的方法==，具体代码逻辑是通过==重写invokationhandler的invoke方法，通过反射的方式对原有方法进行增强==。
- 对于==cglib的enhancer它是面向父类的动态代理==，也就是说它代理一个对象就是==通过继承被代理对象对原有方法增强==，这就意味着它可以增强被代理对象的所有方法，==并且由于反射机制的存在，可以获取到父类方法上的所有注解==。
- 动态代理经常出现在框架中，例如mybatis通过面向接口的动态代理，对接口进行实现。==在spring aop机制中，通过动态代理机制，对方法进行增强，aop中的前置通知，返回通知，异常通知等，都是通过在动态代理过程中，在相对原方法的不同位置执行对应逻辑而实现的==。

---



## 2.Java集合

### 1.【HashMap专题】hashmap 连环炮，看看你能接住多少招🌟🌟🌟🌟🌟

==问题一==：==HashMap 了解吗？平时在什么地方使用过它呢==？（说明：发现没有，我喜欢问使用场景，希望大家也是能够思考使用场景的，因为掌握了这个，你说话更加有说服力）

==我的回答==：

1. HashMap 也可以称作哈希表，它的==底层数据结构是一个可变数组==，并使用==链地址法处理哈希冲突==，具体的实现是遇到哈希冲突时优先以==链表==的形式加到可变数组对应位置的节点后面，且==当可变数组达到一定长度且链表长度也达到一定长度后，会将链表转化为红黑树==，以提高 CRUD 的效率，并且由于红黑树是 “黑节点平衡” 的，因此查询的时间也比较稳定。
2. ==HashMap 主要用于对储存的数据进行高效的随机读写==，比如可根据一个对象的唯一字段对这个对象的集合进行高效的随机读写。

==参考答案==：

- HashMap 也就是哈希表，==底层利用数组支持下标随机访问数据的特性，快速的对键值对进行读写操作==。

---

==问题二==：==HashMap 底层数据结构说一下？（指导：直接说最新的即可，不需要去对比以前的版本，因为面试官也听烦了，另外在说的时候，为了你语言的严谨，一定要强调下是哪个JDK版本的哈）==

==我的回答==：

1. 在 jdk1.8 及以后的版本中，底层数据结构是 “==可变数组 + 链表 + 红黑树==”。首先如果可变数组为空则==先初始化大小为16==，将 key 的 hashCode 经 hash 算法得到 ==hash 值后，`i = (n - 1) & hash` 和当前可变数组大小 - 1作按位与运算，目的是让得到的索引位置不出界==。
2. 如果索引位置没有元素则将 Node 放在这里；否则会==先以链表的形式在其后创建新节点==，然后==判断链表总长是否达到默认值8，达到后即尝试将链表转换为红黑树==。但是值得注意的是，==尝试转换红黑树时如果可变数组的长度小于默认值64，则转化失败，并对可变数组进行扩容==。

==参考答案==：

- 在最新的 JDK 1.8 中，HashMap 的底层数据结构为 “==哈希表 + 链表 + 红黑树==”。当哈希表中出现哈希冲突时，HashMap 采用 “==链地址法==” 来解决，也就是==哈希表中的每个槽位，都会对应一个链表==，所有哈希值相同的元素都会被放到同一个槽位对应的链表中。但随着链表长度的增加，元素的读取效率会下降，==直到达到某个阈值时（目前JDK是8），HashMap 会将链表转化为红黑树==，进一步提升性能。

---

==问题三==：==为什么用红黑树呢？用平衡二叉树不可以吗？或者你讲一讲他们各自的优缺点吗？==

==我的回答==：

1. ==红黑树是弱平衡树==，而==AVL树是强平衡树，其插入和删除节点的速度涉及较多的子树旋转操作==，因此==红黑树的插入和删除节点的速度比AVL树更快==。但是==红黑树需要额外的字段存储节点的颜色信息==，因此在空间上不如AVL树。

==参考答案==：

- ==红黑树是弱平衡二叉树，整棵树可以有局部的不平衡==。==AVL 树是强平衡二叉树==，它严格要求整棵树的平衡性。也就是说，虽然两者的插入，删除复杂度都为 O*(*logn)，实际中 ==AVL 树需要执行更多的旋转操作来保证强平衡性，效率要低于红黑树==。但红黑树也有缺点，==它需要额外的字段来记录每个节点的颜色==，因此会占用更多的存储空间。

----

==问题四==：==为什么选择 8 之后转为红黑树呢？另外链表转为红黑树之后，还会继续转为链表吗？==（最好看过源码说明）

==我的回答==：

1. 当链表的长度过长时，哈希表对这些元素读写的效率会降低，将其==转化为红黑树可以提升读写的效率==。
2. 之所以选择8则是因为==发生哈希冲突导致某一链表的长度达到8并不容易，这是为了防止极端情况下哈希表读写效率降低的风险==。
3. 当==红黑树的节点个数小于6时，会将红黑树转回链表==。这是由于当节点个数较少时，使用红黑树在时间和空间上都反而不如链表。

==参考答案==：

- 这个在源码的注释中有解释，大致意思为：如果元素的哈希值足够随机，理想情况下链表的长度对应的概率符合泊松分布，==达到 8 的概率小于千万分之一==。

	```java
	     * Because /*TreeNodes are about twice the size of regular nodes*/, we
	     * use them only when bins contain enough nodes to warrant use
	     * (see TREEIFY_THRESHOLD). /*And when they become too small (due to
	     * removal or resizing) they are converted back to plain bins*/. In
	     * usages with well-distributed user hashCodes, tree bins are
	     * rarely used. The first values are:
	     *
	     * 0:    0.60653066
	     * 1:    0.30326533
	     * 2:    0.07581633
	     * 3:    0.01263606
	     * 4:    0.00157952
	     * 5:    0.00015795
	     * 6:    0.00001316
	     * 7:    0.00000094
	     * 8:    0.00000006
	     * more: less than 1 in ten million
	```

	也就是说，一般情况下并不会发生链表到红黑树的转化，更多是一种==防止自己选取的哈希算法不好的保底策略==，在极端情况下仍会有较好的效率。

- 但是，当==红黑树的节点小于 6 时，红黑树又会转回链表==，原因是数据量很小的情况下，空间和时间上链表都要比红黑树优秀。==至于为什么要把这个阈值定为 6，而不同样定为 8，主要是而为了防止元素数量在 8 附近导致两种数据结构的频繁转换==。

---

==问题五==：==简单描述下 put 的流程？可以说一下JDK为了效率更快，在 put 的时候，做了哪些优化不？==

==我的回答==：

1. 首先会==调用 HashMap 的 hash 方法根据 key 的 hashCode 生成一个 hash 值==，将其和 KV 一同传入 putVal 方法。

2. 在 putVal 方法中，==首先会检查可变数组是否为空，为空则初始化至16的大小==。然后通过

	```java
	i = (n - 1) & hash
	```

	==计算索引值==，进行按位与运算是为了防止索引值出界。然后==判断索引处节点是否为空==，为空就直接将新的 Node 放置在这里。

3. 如果不为空则==先遍历查看是否已插入该节点，已有则更新 value 值==，否则==尝试以链表形式添加节点==，然后==判断链表总长是否达到默认值8，达到后即尝试将链表转换为红黑树==。但是值得注意的是，==尝试转换红黑树时如果可变数组的长度小于默认值64，则转化失败，并对可变数组进行扩容==。

4. ==最后判断添加完成后可变数组已用节点数是否达到总大小的默认0.75倍==，达到就进行扩容。

5. 优化之一是在==计算索引值时，以按位与运算代替取模运算提升了效率==。

==参考答案==：

- 首先 put( ) 会计算出要插入 key 的哈希值，通过哈希值计算出其在数组中的==索引位置==，如果该位置上没有元素则直接插入，有元素则需要遍历这个位置上的所有元素。==如果能找到与当前键相等的键值对，则将其更新为当前值并返回旧值==，如果找不到与当前键相等的键值对，则需要执行真正的插入操作，将其==插入到链表或者红黑树中==，最后==判断插入后是否需要扩==容。
- put( ) 的优化我印象深的是计算 key 哈希值的 hash( )，主要有==两个优化的点==：==使用位运算代替取模运算==和==对 hashCode 进行搅动计算==。具体来说，可以用x这个公式==将取模转变为位运算来提升性能==，但是同时也需要底层数组的长度是 2 的倍数，这个在 HashMap 的初始化和扩容方法中做了保证。
- 除此之外，==为了进一步降低哈希冲突的概率，hash( ) 又通过多个与运算将哈希值的高位和低位进行搅动，尽可能的做到在不同 key 中哪怕有一个位的不同，都会对最终产生的哈希值造成影响==。

---

==问题六==：==多线程情况下，put 是线程安全的吗？可以简单举个例子，说一下哪里不安全吗？==

==我的回答==：

1. ==put 线程不安全==，因为 HashMap 的 put 和 putVal 方法中并没有采取并发控制的措施。
2. 比如有==大量线程同时向同一个 HashMap 中 put 同一个 KV==，假设索引位置不为空，就可能出现之前的 KV 还没放入 HashMap，==后续线程在遍历链表时发现该 KV 还没写入哈希表中，便向同一个链表中插入大量相同的节点，导致链表过长==，并没有被化为红黑树。

==参考答案==：

- ==不是==，在 JDK 1.7 中==多线程同时进行 put( ) 会出现数据覆盖问题==，在需要扩容时也可能会出现链死循环问题。JDK 1.8 修复了链死循环，==但数据覆盖问题依然存在==。
- ==JDK 1.7== 的 HashMap 底层为数组 + 链表，扩容的 transfer( ) 会遍历原链表中的每个节点，采用==头插法==将其转移到新哈希表槽位的链表中，这个过程在多线程下会==导致新链表中出现环路==，并造成某些元素丢失。
- JDK 1.8 采用的是尾插法，保证了元素在扩容前后的顺序一致，避免了死循环问题，但还会造成数据覆盖。==如两个线程同时执行 put，且两个线程都同时判断槽位为空，则后插入的数据会覆盖先插入的数据==。

---

==问题七==：==如果我想要让 hashmap 变成线程安全的，你觉得可以怎么做？（有时候会扯到 concurrentHashMap，不过咱们这里先不追击这个）==

==我的回答==：

1. ==可以使用 HashTable 代替==，HashTable 给大部分方法用 synchronized 修饰，以加互斥锁的方式实现了线程安全。

==参考答案==：

- 想要解决 HashMap 的线程不安全问题，首先我们不能修改源码，那就要么使用一些 “辅助” 操作，让它变得安全，要么就寻找替代品。首先说的 “辅助” 操作是指，==使用 Collections 类的 synchronizedMap 方法包装一下，它返回由指定映射支持的同步映射，是线程安全的==。换替代品的话，可以考虑 HashTable，==HashTable 通过将整个表上锁来实现线程安全==，某些情况下效率很低。还可以使用 ==ConcurrentHashMap，它使用分段锁或者 CAS 操作来保证线程安全==。

---

==问题八==：==头插法会导致死循环，那你觉得在以前的版本中，为啥会使用头插法呢？==

==我的回答==：

1. 之所以把新元素插到链表头部，是因为==认为新加入的元素在之后更有可能被访问到==，因此放到头部可以略微提升性能。

==参考答案==：

- 采用头插法的话，最新插入的数据就会在链表的最前边，==根据程序的局部性原理，最近被访问的数据很可能不久之后会再次访问==，那么此时可以在 O(1) 时间返回。

---

==问题九==：==那我们再说一说 HashMap 的扩容吧，什么时候会扩容呢？你觉得为啥负载因子为啥选择 0.75 呢？==

==我的回答==：

1. HashMap 扩容的时机一般有两个，==可变数组使用元素个数达到总量乘负载因子==和==链表转化为红黑树时可变数组容量没有达到默认值64==。
2. 负载因子选择为0.75是==空间利用率和哈希冲突率间的一个平衡==。如果==负载因子过低，会导致频繁触发扩容，而浪费较多空间==；而==负载因子过高，会导致迟迟不扩容，提高了哈希冲突发生的风险==。

==参考答案==：

- HashMap 需要扩容时，可以分为几种情况来考虑。
- 首先是在无参的构造函数中。在第一次进行 put 操作之前，HashMap 内部数组为 null，第一次 put 后才会开始==第一次初始化扩容，默认为 16== 。
- 其次是指定了初始容量的构造参数，也是在第一次 put 操作之后才开始初始化扩容，但此时的==容量是第一个不小于指定容量的 2 的幂数==，阈值为计算后容量乘负载因子。
- 其它情况就是，非首次 put，导致容量大于阈值，需要扩容。==容量和阈值都变为原来的 2 倍，负载因子不变==。
- 负载因子为 0,75 的原因，简单来说是 “==哈希冲突” 和 “空间利用率“ 矛盾的一个折中==。原因是，扩容因子是用来计算阈值的，阈值为底层 table 长度乘负载因子，当 HashMap 容量大于阈值时会触发扩容。所以如果负载因子过小，table 中还没填几个元素就要扩容，虽然哈希冲突概率很小，但空间浪费太多。相反，如果负载因子过大，空间利用率是高，但哈希冲突的概率也大大增加。那就取个折中吧，为 0.75。

----

==问题十==：==频繁扩容会导致效率比较低下，那你觉得在平时，在实际的开发场景中，可以怎么优化来避免频繁扩容呢？==

==我的回答==：

1. 在创建哈希表之前合理估算业务的规模，在==哈希表初始化时显示地将哈希表的初始容量设置为大于业务规模的最小2的幂次==。
2. ==优化哈希函数==，提升不同 key 值得到的 hash 值的区分度，降低冲突的概率。

==参考答案==：

- 容易想到的就是，提前预估业务的存储量，设置一个较大的初始容量。==这时不用考虑它是否是 2 的次幂，HashMap 自己会计算出第一个大于等于给定容量的 2 次幂来作为初始容量==。除此之外，可以==自定义负载因子的大小，对哈希函数优化==等等。

---

==问题十一==：==一个场景题：只存60个键值对，需要设置初始化容量吗？设置的话设置多少初始化容量比较好呢？==

==我的回答==：

1. 如果不设置初始化容量的话，==60个键值对可能会16->32->64->128经过最多三次扩容，较为频繁==。
2. 第一个大于60的2的幂次是64，==但是64*0.75=48<60，依然很有可能会触发一次扩容==，而64/0.75=85，==一个场景题：只存60个键值对，需要设置初始化容量吗？设置的话设置多少初始化容量比较好呢？==。

==参考答案==：

- HashMap 默认的初始容量大小为 16。如果不设置初始容量的话，根据规则 size > threshold 时会触发扩容，且 threshold = loadFactor *capacitry，==最终 capacity 会经历 16 – 32 – 64 – 128 三次扩容操作==。==考虑到HashMap 自己会计算出第一个大于等于给定容量的 2 次幂来作为初始容量，所以随机选一个 65 – 128 之间的数作为初始容量即可==。

---



### 2.【ArrayList与LinkedList专题】连环炮，看看你能接住多少招？🌟🌟🌟🌟🌟

==问题一==：==请你说一说 ArrayList 和 LinkedList 区别？==

==我的回答==：

1. ==ArrayList 底层实现是可变数组==，可以通过下标以O(1)的时间复杂度进行读取和修改的操作，但是添加和删除元素涉及到数组元素的迁移，复杂度为O(n)。
2. 而 ==LinkedList 底层实现是双向链表==，可以以O(1)复杂度进行增删操作，但是查找速度为O(n)较慢。
3. 因此涉及较多读取操作的业务建议采用 ArrayList，而数据增删操作较多的业务建议使用 LinkedList，==比如 LRU 和 LFU 缓存就可以使用双向链表实现==。

==参考答案==：

- ==ArrayList 底层是用数组实现的==，根据索引访问元素，使得查询的复杂度仅为 O(1)。但在插入和删除时有数组的复制和移动，复杂度为 O*(*n)；
- ==LinkedList 底层使用双向链表实现的==，由于每个节点都含有前驱和后继节点的引用，所以它插入删除时只需修改这些引用，效率要比 ArrayList 高 。但在查询元素时需要从头节点开始依次遍历整个链表，时间复杂度为 O*(*n)

---

==问题二==：==如果我要删除第 k 个元素，也就是会执行 remove(k)，那么这个 remove 的操作，它们的时间复杂度各自是多少？==

==我的回答==：

1. ArrayList 可以使用下标O(1)定位到第k个元素，以O(n)复杂度删除，整体复杂度为O(n)。
2. LinkedList 需要以O(n)复杂度定位到第k个元素，但只需O(1)时间完成删除，整体复杂度也为O(1)。

==参考答案==：

- 都是 O*(*n) 。
- ArrayList 首先会以 O(1) 时间定位到第 k 个元素，然后将被这个元素分割的两部分复制拼接到一个新数组上，总体为 O*(*n) 。
- LinkedList 首先以 O(*n*) 时间定位到第 k 个元素，然后 O(1) 时间处理这个元素前后节点的引用，总体也为 O*(*n) 。

---

==问题三==：==可以说一说它们的使用场景吗？或者说一说你平时在处理什么事情的时候，用过它们？==

==我的回答==：

1. 对于 ArrayList，我一般在==从数据库中读取一个集合的数据时使用 ArrayList==，因为==后续的业务一般涉及较多数据库数据的读取操作==，而很少涉及增删，并且 ArrayList 的内存占用相比于 LinkedList 也更小。
2. 而 LinkedList 则在==设计 LRU 和 LFU 缓存更新算法时可以使用==。因为==每进行一个操作，就涉及将元素迁移到表头的操作，而双向链表在这个过程中的增删用时均为O(1)==。

==参考答案==：

暂无。

---

==问题四==：==AarrayList 底层实现是数组，数组就会有容量限制，可以简单说一下 ArrayList 的扩容机制吗？==

==我的回答==：

1. ==无参构造的情况下可变数组初始长度为0，第一次扩容会括容到10==。之后按照==1.5倍扩容==。
2. 而有参构造则第一次扩容到指定参数，之后一直按照==1.5倍进行扩容==。

==参考答案==：

- ArrayList 的默认容量为 10，当需要扩容时，会==先申请一个容量为旧容量 1.5 倍的新数组，然后把旧数组复制到新数组中==。值得注意的是，==JDK 1.8 中 ArrayList 底层数组的最大容量为 Integer.MAX_VALUE – 8 ，目的是防止某些虚拟机会在数组中存一些额外的信息导致内存溢出==。

---



### 3.【counrrenthashmap】看看你了解多少？🌟🌟🌟

==问题一==：==counrrenthashmap 是如何实现线程安全的？可以简单说一下为了效率更快，比起 HashTable，counrrenthashmap 作了哪些优化吗？==

==我的回答==：

1. 不了解。

==参考答案==：

- JDK 1.7 中 ConcurrentHashMap 使用了分段锁来实现线程安全。它的底层是一个 Segment 数组，每个 Segment 通过继承 ReetrantLock 来控制自己这部分的加锁。其中每个 Segment 就类似一个 HashTable，这样只要保证每个 Segment 是线程安全的，就能确保整个哈希表也是安全的了。

- JDK 1.8 为了摆脱哈希表中 Segment 个数对并发度的限制，==底层采用和 HashMap 类似的实现：数组 + 链表 + 红黑树==，==加锁用 CAS 和 synchronized 实现==。

- 具体来说，在==进行 putVal 操作时，如果槽位为空，则使用 CAS 插入新节点==。

	```java
	else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
	    if (casTabAt(tab, i, null,
	                 new Node<K,V>(hash, key, value, null)))
	        break;                   // no lock when adding to empty bin
	}
	```

- 如果槽位不为空，则需要==进一步判断其它线程是否在对其扩容，是则协助扩容==，

	```java
	else if ((fh = f.hash) == MOVED)
	    tab = helpTransfer(tab, f);
	```

- ==不是则使用 synchronized 锁住当前槽位==，再进行插入节点操作。

	```java
	else {
	    V oldVal = null;
	    synchronized (f) { // 使用 synchronized 锁住当前槽位
	        if (tabAt(tab, i) == f) {
	            if (fh >= 0) {
	                binCount = 1;
	                for (Node<K,V> e = f;; ++binCount) {
	                    K ek;
	                    if (e.hash == hash &&
	                        ((ek = e.key) == key ||
	                         (ek != null && key.equals(ek)))) {
	                        oldVal = e.val;
	                        if (!onlyIfAbsent)
	                            e.val = value;
	                        break;
	                    }
	                    Node<K,V> pred = e;
	                    if ((e = e.next) == null) {
	                        pred.next = new Node<K,V>(hash, key,
	                                                  value, null);
	                        break;
	                    }
	                }
	            }
	            else if (f instanceof TreeBin) {
	                Node<K,V> p;
	                binCount = 2;
	                if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
	                                               value)) != null) {
	                    oldVal = p.val;
	                    if (!onlyIfAbsent)
	                        p.val = value;
	                }
	            }
	        }
	    }
	    if (binCount != 0) {
	        if (binCount >= TREEIFY_THRESHOLD)
	            treeifyBin(tab, i);
	        if (oldVal != null)
	            return oldVal;
	        break;
	    }
	}
	```

---

==问题二==：==平时我们会经常使用 HashMap，但是 counrrenthashmap 很少使用到，你可以简单说一下什么样的场景下使用 counrrenthashmap 吗==？（指导：这个是个开放性问题，大家思考一下吧，千万不要只说 多线程 情况下使用 counrrenthashmap 哈，那样没有意义，因为有时候，线程的安全，可以由我们程序员来控制，不一定要使用 counrrenthashmap，所以需要大家思考一下）

==我的回答==：

1. 不了解。

==参考答案==：

- 比如==在日志分析时，可以将日志分成多个数据块，同时开启多个线程进行对日志进行并发处理，最终将结果汇总到 ConcurrentHashMap 中==；再比如==一个并发执行的多任务列表，可以用 ConcurrentHashMap 来作为任务管理的数据结构。任务为 Key，任务的执行状态为 Value，多个线程可以同时查找和更新任务的状态，实现对多任务的控制==。

---



### 4.【其他集合问题】简单说一下 list 和 set 的区别？以及使用场景？

==我的回答==：

1. List 和 Set 均实现了 Collection 接口，而 Collection 接口也实现了 Iterable 接口，因此 List 和 Set 均可使用迭代器进行遍历。
2. List 可以顺序存储，允许相同的元素。
3. 而 Set 只能根据 hash() 值在底层可变数组索引的映射进行随机位置的存储，并且不能存储相同的元素。
4. List 的常见实现类为 ArrayList 和 LinkedList。前者可以根据下标快速对数据进行读写操作；后者可实现原地增删节点。
5. Set 的常见实现类为 HashSet 和 TreeSet。其中后者在构造器中需要传入一个 Comparator 实现类以确定排序的方式，而其底层 TreeMap 的 table 数组中每个节点均为一个红黑树。

==参考答案==：

- 两者都继承自 Collection，都是用来存储数据的集合。其中 ==List 接口会维护元素的插入顺序，并且允许根据索引进行数据查询和操作==。而 ==Set 接口只强调元素的不可重复性，不保证元素的特定顺序，也不支持索引查询==。
- List 接口常见的实现类有 ArrayList，LinkedList 等，前者底层为数组，适合随机访问多的场景。后者底层为双向链表，适合插入删除操作多的场景。
- Set 接口常见的实现类有 HashSet，TreeSet 等，前者底层为哈希表，提供快速的插入，删除和查找性能，但不保证元素的顺序。==后者底层为红黑树，元素间可以使用自定义比较器进行排序==。

---



