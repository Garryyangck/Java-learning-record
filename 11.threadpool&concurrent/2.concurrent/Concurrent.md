### 1.可见性、原子性和有序性问题：并发编程Bug的源头

1. ==并发程序幕后的故事==

	> - ==核心矛盾一直存在，就是CPU、内存、I/O 设备的速度差异==。
	> - CPU 增加了==缓存==，以均衡==与内存的速度差异==；
	> - 操作系统增加了==进程、线程，以分时复用 CPU==，进而均衡 CPU 与 I/O 设备的速度差异；
	> - ==编译程序优化指令执行次序==，使得缓存能够得到更加合理地利用。

2. ==源头之一：缓存导致的可见性问题==

	> - 我们假设线程 A 和线程 B 同时开始执行，那么第一次==都会将 count=0 读到各自的 CPU 缓存里（已经破坏可见性了）==，执行完 count+=1 之后，各自 CPU 缓存里的值都是 1，==同时写入内存==后，我们会发现==内存中是 1，而不是我们期望的 2==。之后由于各自的 CPU 缓存里都有了 count 的值，两个线程都是基于 CPU 缓存里的 count 值来计算，所以导致最终 count 的值都是小于 20000 的。这就是缓存的==可见性问题==。

3. ==源头之二：线程切换带来的原子性问题==

	> - 操作系统允许某个进程执行一小段时间，例如 50 毫秒，==过了 50 毫秒操作系统就会重新选择一个进程来执行==（我们称为“任务切换”），这个 50 毫秒称为“==时间片==”。
	>
	> - ==线程切换示意图==：
	>
	> 	![线程切换示意图](Concurrent.assets/202201211507257.png)
	>
	> - ==操作系统做任务切换，可以发生在任何一条 CPU 指令执行完==。
	>
	> - ![非原子操作的执行路径示意图](Concurrent.assets/202201211507627.png)
	>
	> - ==我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性==。

4. ==源头之三：编译优化带来的有序性问题==

	> - ==编译器为了优化性能，有时候会改变程序中语句的先后顺序==，例如程序中：“a=6；b=7；”编译器优化后可能变成“b=7；a=6；”，在这个例子中，编译器调整了语句的顺序，但是不影响程序的最终结果。不过==有时候编译器及解释器的优化可能导致意想不到的 Bug==。
	>
	> - ==例子==：
	>
	> 	- ```java
	> 		public class Singleton {
	> 		    static Singleton instance;
	> 		    static Singleton getInstance(){
	> 		        if (instance == null) {
	> 		            synchronized(Singleton.class) {
	> 		                if (instance == null)
	> 		                    instance = new Singleton();
	> 		            }
	> 		        }
	> 		        return instance;
	> 		    }
	> 		}
	> 		```
	>
	> 	- 我们以为的 new 操作应该是：
	>
	> 		1. 分配一块内存 M；
	> 		2. 在内存 M 上初始化 Singleton 对象；
	> 		3. 然后 M 的地址赋值给 instance 变量。
	>
	> 	- 但是实际上优化后的执行路径却是这样的：
	>
	> 		1. 分配一块内存 M；
	> 		2. 将 M 的地址赋值给 instance 变量；
	> 		3. 最后在内存 M 上初始化 Singleton 对象。
	>
	> 	- ![双重检查创建单例的异常执行路径](Concurrent.assets/202201211507166.png)
	>
	> 	- 当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance() 方法，那么==线程 B 在执行第一个判断时会发现 instance != null ，所以直接返回 instance，而此时的 instance 是没有初始化过的==，如果我们这个时候访问 instance 的成员变量就可能触发==空指针异常==。

5. 在介绍可见性、原子性、有序性的时候，特意提到==缓存导致的可见性问题==，==线程切换带来的原子性问题==，==编译优化带来的有序性问题==，其实缓存、线程、编译优化的目的和我们写并发程序的目的是相同的，都是提高程序性能。

---



### 2.Java内存模型：看Java如何解决可见性和有序性问题

1. ==什么是 Java 内存模型？==

	> - Java 内存模型规范了 JVM ==如何提供按需禁用缓存和编译优化的方法== 。具体来说，这些方法包括 ==volatile==、==synchronized== 和 ==final== 三个关键字，以及六项 ==Happens-Before 规则==，这也正是本期的重点内容。

2. ==使用 volatile 的困惑==

	> - volatile 关键字并不是 Java 语言的特产，C 语言里也有，它最原始的意义就是==禁用 CPU 缓存==。

3. ==Happens-Before 规则==

	> - Happens-Before 真正要表达的是：==前面一个操作的结果对后续操作是可见的==。
	>
	> - ==Happens-Before 约束了编译器的优化行为==，虽允许编译器优化，但是==要求编译器优化后一定遵守 Happens-Before 规则==。
	>
	> - ==Happens-Before 的六项规则==：
	>
	> 	1. ==程序的顺序性规则==
	>
	> 		- 程序==前面对某个变量的修改一定是对后续操作可见的==。
	>
	> 	2. ==volatile 变量规则==
	>
	> 		- 对一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 变量的读操作。
	>
	> 	3. ==传递性==
	>
	> 		- 如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。
	>
	> 		- ![示例代码中的传递性规则](Concurrent.assets/202201211507686.png)
	>
	> 		- “x=42” Happens-Before 写变量 “v=true” ，这是规则 1 的内容；
	>
	> 			写变量“v=true” Happens-Before 读变量 “v=true”，这是规则 2 的内容 。
	>
	> 			==如果线程 B 读到了“v=true”，那么线程 A 设置的“x=42”对线程 B 是可见的==。也就是说，==线程 B 能看到 “x = 42==” ，有没有一种恍然大悟的感觉？这就是 1.5 版本==对 volatile 语义的增强==，这个增强意义重大，1.5 版本的并发工具包（java.util.concurrent）就是靠 volatile 语义来搞定可见性的。
	>
	> 	4. ==管程中锁的规则==
	>
	> 		- 这条规则是指==对一个锁的解锁 Happens-Before 于后续对这个锁的加锁==。
	> 		- ==管程==是一种通用的同步原语，==在 Java 中指的就是 synchronized，synchronized 是 Java 里对管程的实现==。
	>
	> 	5. ==线程 start() 规则==
	>
	> 		- 这条是关于线程启动的。它是指==主线程 A 启动子线程 B 后，子线程 B 能够看到主线程 A 在启动子线程 B 前的操作==。
	>
	> 		- ```java
	> 			Thread B = new Thread(()->{
	> 			  // 主线程调用B.start()之前
	> 			  // 所有对共享变量的修改，此处皆可见
	> 			  // 此例中，var==77
	> 			});
	> 			// 此处对共享变量var修改
	> 			var = 77;
	> 			// 主线程启动子线程
	> 			B.start();
	> 			```
	>
	> 	6. ==线程 join() 规则==
	>
	> 		- 如果在==线程 A 中，调用线程 B 的 join() 并成功返回，那么线程 B 中的任意操作 Happens-Before 于该 join() 操作的返回==。
	>
	> 		- ```java
	> 			Thread B = new Thread(()->{
	> 			  // 此处对共享变量var修改
	> 			  var = 66;
	> 			});
	> 			// 例如此处对共享变量修改，
	> 			// 则这个修改结果对线程B可见
	> 			// 主线程启动子线程
	> 			B.start();
	> 			B.join()
	> 			// 子线程所有对共享变量的修改
	> 			// 在主线程调用B.join()之后皆可见
	> 			// 此例中，var==66
	> 			```

4. ==被我们忽视的 final==

	> - ==final 修饰变量时，初衷是告诉编译器：这个变量生而不变，可以可劲儿优化==。
	>
	> - 在 1.5 以后 Java 内存模型对 final 类型变量的重排进行了约束。现在==只要我们提供正确构造函数没有“逸出”，就不会出问题==了。
	>
	> 	“逸出”有点抽象，我们还是举个例子吧，在下面例子中，在构造函数里面将 this 赋值给了全局变量 global.obj，这就是“逸出”，线程==通过 global.obj 读取 x 是有可能读到 0 的（编译优化把`global.obj = this;`优化到最前面）==。因此我们一定要避免“逸出”。
	>
	> 	```java
	> 	// 以下代码来源于【参考1】
	> 	final int x;
	> 	// 错误的构造函数
	> 	public FinalFieldExample() { 
	> 	  x = 3;
	> 	  y = 4;
	> 	  // 此处就是讲this逸出，
	> 	  global.obj = this;
	> 	}
	> 	```

5. ==Happens-Before 的语义本质上是一种可见性，A Happens-Before B 意味着 A 事件对 B 事件来说是可见的，无论 A 事件和 B 事件是否发生在同一个线程里==。例如 A 事件发生在线程 1 上，B 事件发生在线程 2 上，Happens-Before 规则保证线程 2 上也能看到 A 事件的发生。

---



### 3.互斥锁（上）：解决原子性问题

1. ==Java 语言提供的锁技术：synchronized==

	> - 我们把一段需要互斥执行的代码称为==临界区==。
	> - 当修饰==静态方法的时候，锁定的是当前类的 Class 对象==，在上面的例子中就是 Class X；
	> - 当修饰==非静态方法的时候，锁定的是当前实例对象 this==。

2. ==锁和受保护资源的关系==

	> - ==受保护资源和锁之间的关联关系是 N:1 的关系==。
	>
	> - ```java
	> 	class SafeCalc {
	> 	    long value = 0L;
	> 	    synchronized long get() {
	> 	        return value;
	> 	    }
	> 	    synchronized void addOne() {
	> 	        value += 1;
	> 	    }
	> 	}
	> 	```
	>
	> 	![保护临界区 get() 和 addOne() 的示意图](Concurrent.assets/202201211508334.png)
	>
	> - ==如果把 addOne 改为 static 方法，那么就会导致并发问题==：
	>
	> 	```java
	> 	class SafeCalc {
	> 	    static long value = 0L;
	> 	    synchronized long get() {
	> 	        return value;
	> 	    }
	> 	    synchronized static void addOne() {
	> 	        value += 1;
	> 	    }
	> 	}
	> 	```
	>
	> 	如果你仔细观察，就会发现改动后的代码是==用两个锁保护一个资源==。这个受保护的资源就是静态变量 value，两个锁分别是 this 和 SafeCalc.class。我们可以用下面这幅图来形象描述这个关系。
	>
	> 	![两把锁保护一个资源的示意图](Concurrent.assets/202201211508332.png)
	>
	> 	由于临界区 get() 和 addOne() 是用两个锁保护的，因此==这两个临界区没有互斥关系==，==临界区 addOne() 对 value 的修改对临界区 get() 也没有可见性保证，这就导致并发问题==了。
	>
	> - ==可以用一把锁来保护多个资源，但是不能用多把锁来保护一个资源==。

---



### 4.互斥锁（下）：如何用一把锁保护多个资源？

1. ==保护没有关联关系的多个资源==

	> - 我们用两把锁，取款和修改密码是可以并行的。==用不同的锁对受保护资源进行精细化管理，能够提升性能==。这种锁还有个名字，叫==细粒度锁==。

2. ==保护有关联关系的多个资源==

	> - ```java
	> 	class Account {
	> 	  private int balance;
	> 	  // 转账
	> 	  synchronized void transfer(
	> 	      Account target, int amt){
	> 	    if (this.balance > amt) {
	> 	      this.balance -= amt;
	> 	      target.balance += amt;
	> 	    }
	> 	  } 
	> 	}
	> 	```
	>
	> - 假设线程 1 执行账户 A 转账户 B 的操作，线程 2 执行账户 B 转账户 C 的操作。这两个线程分别在两颗 CPU 上同时执行，那它们是互斥的吗？我们期望是，但实际上并不是。
	>
	> - 最终账户 B 的余额可能是 300（线程 1 后于线程 2 写 B.balance，线程 2 写的 B.balance 值被线程 1 覆盖），可能是 100（线程 1 先于线程 2 写 B.balance，线程 1 写的 B.balance 值被线程 2 覆盖），就是不可能是 200。
	>
	> - ![并发转账示意图](Concurrent.assets/202201211508818.png)

3. ==使用锁的正确姿势==

	> - ![img](Concurrent.assets/202201192205980.png)
	> - 锁 Account.class

---



### 5.一不小心就死锁了，怎么办？

1. ==向现实世界要答案==

	> - 用两把锁就实现了，转出账本一把，转入账本另一把。在 transfer() 方法内部，我们首先尝试锁定转出账户 this（先把转出账本拿到手），然后尝试锁定转入账户 target（再把转入账本拿到手），==只有当两把锁都获取时，才执行转账操作==。这个逻辑可以图形化为下图这个样子。
	> - ![两个转账操作并行示意图](Concurrent.assets/202201211508575.png)

2. ==没有免费的午餐==

	> - ==使用细粒度锁是有代价的，这个代价就是可能会导致死锁==。
	> - ==死锁==的一个比较专业的定义是：==一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象==。

3. ==如何预防死锁==

	> - ==只有以下这四个条件都发生时才会出现死锁==：
	> 	1. ==资源互斥==，共享资源 X 和 Y 只能被一个线程占用；
	> 	2. ==占有且等待==，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；
	> 	3. ==不可抢占==，其他线程不能强行抢占线程 T1 占有的资源；
	> 	4. ==循环等待==，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源。

4. ==破坏占用且等待条件==

	> - 要破坏这个条件，可以==一次性申请所有资源==。
	> - “==同时申请多个资源”这个操作是一个临界区，我们也需要一个角色（Java 里面的类）来管理这个临界区，我们就把这个角色定为 Allocator==。它有两个重要功能，分别是：==同时申请资源 apply() 和同时释放资源 free()==。

5. ==破坏不可抢占条件==

	> - 核心是要能够==主动释放它占有的资源==，这一点 ==synchronized 是做不到的==。原因是 ==synchronized 申请资源的时候，如果申请不到，线程直接进入阻塞状态==了，而==线程进入阻塞状态，啥都干不了，也释放不了线程已经占有的资源==。
	> - 但是 ==java.util.concurrent 这个包下面提供的 Lock 是可以轻松解决这个问题==。

6. ==破坏循环等待条件==

	> - ==对资源进行排序，然后按序申请资源==。
	>
	> - 比如按照账户的 id 大小排序，由小到大的顺序依次锁定账户，==这样两个账户争夺时都会优先争夺较小的账户，得不到则阻塞，得到了就可以依次得到其它所有锁==。
	>
	> - ```java
	> 	class Account {
	> 	    private int id;
	> 	    private int balance;
	> 	    // 转账
	> 	    void transfer(Account target, int amt){
	> 	        Account left = this        
	> 	            Account right = target;    
	> 	        if (this.id > target.id) { // 排序
	> 	            left = target;           
	> 	            right = this;            
	> 	        }                          
	> 	        // 优先争夺较小的账户
	> 	        synchronized(left){
	> 	            // 得到了就可以依次得到其它所有锁
	> 	            synchronized(right){ 
	> 	                if (this.balance > amt){
	> 	                    this.balance -= amt;
	> 	                    target.balance += amt;
	> 	                }
	> 	            }
	> 	        }
	> 	    } 
	> 	}
	> 	```

7. ==用细粒度锁来锁定多个资源时，要注意死锁的问题==。

---



